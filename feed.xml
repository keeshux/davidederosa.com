<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://davidederosa.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://davidederosa.com/" rel="alternate" type="text/html" /><updated>2025-07-10T12:10:15+02:00</updated><id>https://davidederosa.com/feed.xml</id><title type="html">Davide De Rosa</title><subtitle>I make software. I look around me.</subtitle><author><name>Davide De Rosa</name></author><entry><title type="html">Cross-platform Swift: C interop (pt. 2)</title><link href="https://davidederosa.com/cross-platform-swift/c-interop-part-two/" rel="alternate" type="text/html" title="Cross-platform Swift: C interop (pt. 2)" /><published>2025-07-10T00:00:00+02:00</published><updated>2025-07-10T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-c-interop-part-two</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/c-interop-part-two/"><![CDATA[<p>While writing C in a Swift context makes no difference at all, it takes a few tricks to reduce the friction in Swift code that embeds C routines. Let’s go through them together.</p>

<h2 id="the-mystique-of-swift-pointers">The mystique of Swift pointers</h2>

<p>Swift has often changed the way it interacts with C entities, especially around version 3 and 4, IIRC. It has changed so much that upgrading Xcode to a new minor version would likely break some code with obscure error messages. To this day, the ambiguity around Swift pointer types still beats me.</p>

<p>Have you ever noticed how many variants exist?</p>

<ul>
  <li><a href="https://developer.apple.com/documentation/swift/unsafepointer">UnsafePointer</a></li>
  <li><a href="https://developer.apple.com/documentation/swift/unsafebufferpointer">UnsafeBufferPointer</a></li>
  <li><a href="https://developer.apple.com/documentation/swift/unsaferawpointer">UnsafeRawPointer</a></li>
  <li><a href="https://developer.apple.com/documentation/swift/unsaferawbufferpointer">UnsafeRawBufferPointer</a></li>
</ul>

<p>Each of them with its mutable counterpart, totalling EIGHT pointer types. Don’t be offended, Swift, but this is ridiculously complex, and I hope that someday that part of the language will be properly simplified. It’s the single thing, hands down, that makes Swift/C interop unappealing.</p>

<p>Personally, I have a hard time getting them right, and find myself bruteforcing the Swift code until I get it to compile. Don’t even get me started on the <code class="language-plaintext highlighter-rouge">withUnsafeBytes()</code> variants and the horrendously deceptive compiler/LSP errors that they trigger. They are very similar to the ones you stumble upon in complex SwiftUI closures with generics, to get the idea.</p>

<p>Let me show you some lovely examples:</p>

<p><img src="/s/f/cross-platform-swift/c-interop-compile-01.png" alt="" /></p>

<p><img src="/s/f/cross-platform-swift/c-interop-compile-02.png" alt="" /></p>

<p><img src="/s/f/cross-platform-swift/c-interop-compile-03.png" alt="" /></p>

<p><img src="/s/f/cross-platform-swift/c-interop-compile-04.png" alt="" /></p>

<h2 id="unsafe-with-closures">Unsafe <code class="language-plaintext highlighter-rouge">with</code> closures</h2>

<p>When using <code class="language-plaintext highlighter-rouge">withUnsafeBytes()</code>, <code class="language-plaintext highlighter-rouge">withCString()</code>, and other similar closures, make sure to follow these ultimate 3 rules:</p>

<ul>
  <li><strong>Never ever let the closure arguments outlive the closure</strong>.</li>
  <li><strong>Never</strong>.</li>
  <li><strong>Ever</strong>.</li>
</ul>

<p>Thank me later. You’re welcome.</p>

<p>This is another clunky syntax of Swift. Especially if your C function requires multiple variables to be mapped to their “unsafe representation”, you may quickly end up with this beautiful accordion:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">var</span> <span class="nv">b</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">var</span> <span class="nv">c</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">a</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="n">pa</span> <span class="k">in</span>
    <span class="n">b</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="n">pb</span> <span class="k">in</span>
        <span class="n">c</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="n">pc</span> <span class="k">in</span>
            <span class="nf">my_demanding_c_function</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, disgusted by the indentation overflow, you might look for ways to make the code more linear, and naturally think of returning the pointers that the closures provide:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">pa</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">pb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">pc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
<span class="nf">my_demanding_c_function</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
</code></pre></div></div>

<p>Much, much cleaner, only to find out that this code will crash, sooner or later, at some point of your life. They call it <em>unpredictable behavior</em>, and I guess it’s for the same reasons why you shouldn’t return a reference to a local variable. So, remember <em>the</em> rule, and kindly accept the nested closures. Or, keep reading.</p>

<h2 id="bridging-to-swift">Bridging to Swift</h2>

<p>Ironically, the above constructs are enough to minimize or even discourage the use of C in Swift. The time I wasted on Swift pointers made me constantly reconsider the balance between Swift and C code %, in that exposing C pointers to Swift was so frustrating that I’d rather write the whole logic in C, and let Swift be a thin wrapper. After all, it’s the best approach because going back and forth from and to Swift/C types is very inconvenient. Why would you ever use a bare <code class="language-plaintext highlighter-rouge">memcpy()</code> or <code class="language-plaintext highlighter-rouge">strlen()</code> in Swift? There are better, native alternatives.</p>

<p>The point of C interop is to perform the low-level logic in C files, and only expose in/out types that are easier to funnel to Swift for use at higher levels of abstraction, especially if you make good use of the <code class="language-plaintext highlighter-rouge">_Nullable</code> and <code class="language-plaintext highlighter-rouge">_Nonnull</code> clang qualifiers.</p>

<p>All in all, Swift bridges C <code class="language-plaintext highlighter-rouge">struct</code> as if it were a Swift value type, and pointers to <code class="language-plaintext highlighter-rouge">struct</code> are naturally mapped to <code class="language-plaintext highlighter-rouge">UnsafePointer&lt;T&gt;</code> or <code class="language-plaintext highlighter-rouge">UnsafeMutablePointer&lt;T&gt;</code> according to their <code class="language-plaintext highlighter-rouge">const</code> modifier. <code class="language-plaintext highlighter-rouge">enum</code> and <code class="language-plaintext highlighter-rouge">union</code> also behave pretty much the same way.</p>

<p>So, what’s the matter? Why would one need more than this? Well, because everything is cool until you hit pointers, strings, and memory management.</p>

<h2 id="opaquepointer">OpaquePointer</h2>

<p>Sure, a C <code class="language-plaintext highlighter-rouge">struct</code> is nicely bridged to Swift, until it has less linear (yet super common) fields like:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span> <span class="o">**</span><span class="n">ptr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">**</span><span class="n">matrix</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_cool_struct</span><span class="p">;</span>
</code></pre></div></div>

<p>Good luck with the bridged Swift version of this structure, and good luck to manage its memory layout properly.</p>

<p>But this is when I casually discovered the magic wand, the ultimate structure for C objects in Swift: <a href="https://developer.apple.com/documentation/swift/opaquepointer">OpaquePointer</a>.</p>

<p><img src="/s/f/cross-platform-swift/c-interop-opaque-pointers.jpg" alt="Courtesy of Reddit" /></p>

<p>Opaque pointers are a popular way to attain OOP-like encapsulation in C. You write a <em>forward declaration</em> in a .h header, then the full definition in a .c file. By doing so, the type internals are only exposed to the .c file that needs them to implement its logic. Externally, the pointers are treated as generic I/O handles, and Swift can’t see through them because it can only bridge what it sees in the C headers, i.e. a shallow type name. For the record, Objective-C can do this with <code class="language-plaintext highlighter-rouge">@class MyType</code>.</p>

<h3 id="the-benefits-of-opaquepointer">The benefits of OpaquePointer</h3>

<p>For example, if we have this structure in a C header:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// .h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">tls_channel_options</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">opt</span><span class="p">;</span>
    <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">ssl_ctx</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">buf_cipher</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">buf_plain</span><span class="p">;</span>

    <span class="n">SSL</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">ssl</span><span class="p">;</span>
    <span class="n">BIO</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">bio_plain</span><span class="p">;</span>
    <span class="n">BIO</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">bio_cipher_in</span><span class="p">;</span>
    <span class="n">BIO</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">bio_cipher_out</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">is_connected</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tls_channel</span><span class="p">;</span>
</code></pre></div></div>

<p>and return e.g. <code class="language-plaintext highlighter-rouge">tls_channel *</code> from a function, its type will map to <code class="language-plaintext highlighter-rouge">UnsafeMutablePointer&lt;tls_channel&gt;</code> in Swift, and we’ll be able to access its fields with <code class="language-plaintext highlighter-rouge">.pointee</code>. We don’t need or want that level of detail, those are C concerns.</p>

<p>Therefore, we split the definitions across two files. The header with a forward pointer declaration:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// .h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tls_channel</span> <span class="o">*</span><span class="n">tls_channel_ctx</span><span class="p">;</span>
</code></pre></div></div>

<p>and the .c file, with the full definition, mind the lack of <code class="language-plaintext highlighter-rouge">typedef</code> here:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// .c</span>
<span class="k">struct</span> <span class="n">tls_channel</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">tls_channel_options</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">opt</span><span class="p">;</span>
    <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">ssl_ctx</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>At this point, we replace <code class="language-plaintext highlighter-rouge">tls_channel *</code> with the <code class="language-plaintext highlighter-rouge">tls_channel_ctx</code> alias:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// before</span>
<span class="n">tls_channel</span> <span class="o">*</span><span class="nf">tls_create_func</span><span class="p">();</span>

<span class="c1">// after</span>
<span class="n">tls_channel_ctx</span> <span class="nf">tls_create_func</span><span class="p">();</span>
</code></pre></div></div>

<p>and Swift will consider the returned object to be of <code class="language-plaintext highlighter-rouge">OpaquePointer</code> type.</p>

<p>Benefits:</p>

<ul>
  <li>No unsafe Swift pointers involved ever again</li>
  <li>No unsafe <code class="language-plaintext highlighter-rouge">with</code> closures, you pass the object as is to C functions from Swift</li>
  <li>The C layer is the only responsible of the object, and Swift cannot mess with it</li>
</ul>

<p>Granted, it’s not a one-size-fits-it-all, but for complex C objects that need to cross the Swift boundary often, opaque pointers may be a good bet.</p>

<p><img src="/s/f/cross-platform-swift/c-interop-opaque-pointers-example.png" alt="Example in Swift" /></p>

<h2 id="debugging">Debugging</h2>

<p>Talking about the Xcode debugger, it is generally able to debug C code called from Swift without issues. Not that I pushed this to the limit, but so far I’ve only noticed two places where the debugger is unhelpful.</p>

<p>For example, due to their very nature, you don’t get to see what opaque pointers point to in Swift code. However, opaque pointers encapsulate private data, so a logical deduction would be that you’d rather put your breakpoint in C files, and let Swift treat them as a black box.</p>

<p>The other situation is <code class="language-plaintext highlighter-rouge">inline</code> functions, where the Xcode debugger clearly struggles to step in (with reason?).</p>

<h2 id="bottom-line">Bottom line</h2>

<p>Interacting with Swift pointers is painful, but we can make our lives easier with some workarounds. The friction is directly proportional to the surface we expose to Swift, so we need to hide the C internals as much as possible, and minimize the roundtrips across languages. Use opaque pointers when types become complex.</p>

<p>Now that we learned a few tricks about C interop, we can go back to the SwiftPM manifest to manage multiple, alternative implementations. See you in the next article.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><summary type="html"><![CDATA[While writing C in a Swift context makes no difference at all, it takes a few tricks to reduce the friction in Swift code that embeds C routines. Let’s go through them together. The mystique of Swift pointers Swift has often changed the way it interacts with C entities, especially around version 3 and 4, IIRC. It has changed so much that upgrading Xcode to a new minor version would likely break some code with obscure error messages. To this day, the ambiguity around Swift pointer types still beats me. Have you ever noticed how many variants exist? UnsafePointer UnsafeBufferPointer UnsafeRawPointer UnsafeRawBufferPointer Each of them with its mutable counterpart, totalling EIGHT pointer types. Don’t be offended, Swift, but this is ridiculously complex, and I hope that someday that part of the language will be properly simplified. It’s the single thing, hands down, that makes Swift/C interop unappealing. Personally, I have a hard time getting them right, and find myself bruteforcing the Swift code until I get it to compile. Don’t even get me started on the withUnsafeBytes() variants and the horrendously deceptive compiler/LSP errors that they trigger. They are very similar to the ones you stumble upon in complex SwiftUI closures with generics, to get the idea. Let me show you some lovely examples: Unsafe with closures When using withUnsafeBytes(), withCString(), and other similar closures, make sure to follow these ultimate 3 rules: Never ever let the closure arguments outlive the closure. Never. Ever. Thank me later. You’re welcome. This is another clunky syntax of Swift. Especially if your C function requires multiple variables to be mapped to their “unsafe representation”, you may quickly end up with this beautiful accordion: var a = ... var b = ... var c = ... a.withUnsafeBytes { pa in b.withUnsafeBytes { pb in c.withUnsafeBytes { pc in my_demanding_c_function(pa, pb, pc) } } } Then, disgusted by the indentation overflow, you might look for ways to make the code more linear, and naturally think of returning the pointers that the closures provide: let pa = a.withUnsafeBytes { $0 } let pb = b.withUnsafeBytes { $0 } let pc = c.withUnsafeBytes { $0 } my_demanding_c_function(pa, pb, pc) Much, much cleaner, only to find out that this code will crash, sooner or later, at some point of your life. They call it unpredictable behavior, and I guess it’s for the same reasons why you shouldn’t return a reference to a local variable. So, remember the rule, and kindly accept the nested closures. Or, keep reading. Bridging to Swift Ironically, the above constructs are enough to minimize or even discourage the use of C in Swift. The time I wasted on Swift pointers made me constantly reconsider the balance between Swift and C code %, in that exposing C pointers to Swift was so frustrating that I’d rather write the whole logic in C, and let Swift be a thin wrapper. After all, it’s the best approach because going back and forth from and to Swift/C types is very inconvenient. Why would you ever use a bare memcpy() or strlen() in Swift? There are better, native alternatives. The point of C interop is to perform the low-level logic in C files, and only expose in/out types that are easier to funnel to Swift for use at higher levels of abstraction, especially if you make good use of the _Nullable and _Nonnull clang qualifiers. All in all, Swift bridges C struct as if it were a Swift value type, and pointers to struct are naturally mapped to UnsafePointer&lt;T&gt; or UnsafeMutablePointer&lt;T&gt; according to their const modifier. enum and union also behave pretty much the same way. So, what’s the matter? Why would one need more than this? Well, because everything is cool until you hit pointers, strings, and memory management. OpaquePointer Sure, a C struct is nicely bridged to Swift, until it has less linear (yet super common) fields like: typedef struct { char str[32]; uint16_t *buf; const void (*)(char **ptr); int **matrix; } my_cool_struct; Good luck with the bridged Swift version of this structure, and good luck to manage its memory layout properly. But this is when I casually discovered the magic wand, the ultimate structure for C objects in Swift: OpaquePointer. Opaque pointers are a popular way to attain OOP-like encapsulation in C. You write a forward declaration in a .h header, then the full definition in a .c file. By doing so, the type internals are only exposed to the .c file that needs them to implement its logic. Externally, the pointers are treated as generic I/O handles, and Swift can’t see through them because it can only bridge what it sees in the C headers, i.e. a shallow type name. For the record, Objective-C can do this with @class MyType. The benefits of OpaquePointer For example, if we have this structure in a C header: // .h typedef struct { const tls_channel_options *_Nonnull opt; SSL_CTX *_Nonnull ssl_ctx; size_t buf_len; uint8_t *_Nonnull buf_cipher; uint8_t *_Nonnull buf_plain; SSL *_Nonnull ssl; BIO *_Nonnull bio_plain; BIO *_Nonnull bio_cipher_in; BIO *_Nonnull bio_cipher_out; bool is_connected; } tls_channel; and return e.g. tls_channel * from a function, its type will map to UnsafeMutablePointer&lt;tls_channel&gt; in Swift, and we’ll be able to access its fields with .pointee. We don’t need or want that level of detail, those are C concerns. Therefore, we split the definitions across two files. The header with a forward pointer declaration: // .h typedef struct tls_channel *tls_channel_ctx; and the .c file, with the full definition, mind the lack of typedef here: // .c struct tls_channel { const tls_channel_options *_Nonnull opt; SSL_CTX *_Nonnull ssl_ctx; // ... }; At this point, we replace tls_channel * with the tls_channel_ctx alias: // before tls_channel *tls_create_func(); // after tls_channel_ctx tls_create_func(); and Swift will consider the returned object to be of OpaquePointer type. Benefits: No unsafe Swift pointers involved ever again No unsafe with closures, you pass the object as is to C functions from Swift The C layer is the only responsible of the object, and Swift cannot mess with it Granted, it’s not a one-size-fits-it-all, but for complex C objects that need to cross the Swift boundary often, opaque pointers may be a good bet. Debugging Talking about the Xcode debugger, it is generally able to debug C code called from Swift without issues. Not that I pushed this to the limit, but so far I’ve only noticed two places where the debugger is unhelpful. For example, due to their very nature, you don’t get to see what opaque pointers point to in Swift code. However, opaque pointers encapsulate private data, so a logical deduction would be that you’d rather put your breakpoint in C files, and let Swift treat them as a black box. The other situation is inline functions, where the Xcode debugger clearly struggles to step in (with reason?). Bottom line Interacting with Swift pointers is painful, but we can make our lives easier with some workarounds. The friction is directly proportional to the surface we expose to Swift, so we need to hide the C internals as much as possible, and minimize the roundtrips across languages. Use opaque pointers when types become complex. Now that we learned a few tricks about C interop, we can go back to the SwiftPM manifest to manage multiple, alternative implementations. See you in the next article.]]></summary></entry><entry><title type="html">Cross-platform Swift: C interop (pt. 1)</title><link href="https://davidederosa.com/cross-platform-swift/c-interop-part-one/" rel="alternate" type="text/html" title="Cross-platform Swift: C interop (pt. 1)" /><published>2025-07-09T00:00:00+02:00</published><updated>2025-07-09T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-c-interop-part-one</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/c-interop-part-one/"><![CDATA[<p>This is where the fun begins. <a href="https://github.com/passepartoutvpn/partout">Partout</a>, the library I talk about in this series, is a networking library. As such, there are places where code control and performance are paramount. The integration of Swift with the C language for low-level routines is neat, and SwiftPM makes it very easy to mix Swift and C code as if they were the same thing.</p>

<h2 id="the-dangers-of-apple-mix-and-match">The dangers of Apple “Mix and Match”</h2>

<p><img src="/s/f/cross-platform-swift/c-interop-objc-tinky-winky.jpg" alt="ObjC is the Tinky Winky hand" /></p>

<p>I said “mix Swift and C code”, but I should have said “Swift, C, and Objective-C code”. Given that Swift was born off the ribs of Objective-C and the everlasting NeXSTEP library –I know you love that ubiquitous <code class="language-plaintext highlighter-rouge">NS</code> prefix–, it still owes a big legacy to that system. Since the beginning, Apple offered great tools to make <a href="https://developer.apple.com/documentation/swift/importing-objective-c-into-swift">the migration from ObjC to Swift</a> as seamless as possible. In fact, the process has been so smooth that you may have a hard time spotting the Objective-C entities of a Swift codebase.</p>

<p>While this is amazing for Apple-oriented software with plenty of legacy, this is no less than a disgrace when you port Swift elsewhere, because <a href="/cross-platform-swift/#2-objc-no-thanks">Objective-C is not available to Swift</a> out of the Apple ecosystem. At least, not easily <em>at all</em>.</p>

<h2 id="embrace-the-power-of-c">Embrace the power of C</h2>

<p>The mix-and-match transition to Swift may lead your codebase to a place where it’s very difficult to gauge the extent of the Objective-C legacy. Why is this important? Because if your intent is going cross-platform, you’d better port all your Objective-C code to good old C. The alternative is manually linking against <a href="https://www.gnustep.org/">GNUstep</a>, but it’s niche GPL software, and adds unnecessary complexity to keep around a language that is already obsolete.</p>

<p>In my case, the low-level part of my OpenVPN implementation in Partout was written in Objective-C plus OpenSSL, so I decided it was time to <a href="https://github.com/passepartoutvpn/partout/milestone/4?closed=1">patiently write a new C version</a>.</p>

<p>You have no idea how thrilled I am that <strong>this new Swift/C implementation now works on Apple, Windows, Linux, and Android</strong>!</p>

<p>It took me a couple of weeks to have a successful connection over the new code, and not only was it more <em>pleasant</em> (Objective-C is not praised for its beauty), it was also significantly <em>faster</em>. The image below shows a speed test comparing the performance of my C (1) and ObjC (2) implementations of the OpenVPN protocol over the same 5G connection.</p>

<p>Can I finally mention the joy of using C again after years of high-level programming?</p>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpartout%2Fblob%2F66f3ed5c01c8d357a7b625a1067f19f368698124%2FSources%2FCrypto%2FOpenSSL_ObjC%2FCryptoAEAD.m%23L37-L58&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpartout%2Fblob%2F66f3ed5c01c8d357a7b625a1067f19f368698124%2FSources%2FCrypto%2FOpenSSL_C%2Fcrypto_aead.c%23L26-L42&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<p><img src="/s/f/cross-platform-swift/c-interop-speed-test.png" alt="OpenVPN over C versus ObjC" /></p>

<h2 id="let-countless-options-unfold">Let countless options unfold</h2>

<p>As you dig into C interop, you realize how many things you can do with Swift in both an abstract and performant fashion. WWDC 2024 even introduced the <a href="https://www.swift.org/get-started/embedded/">Embedded Swift</a> mode to <em>really</em> go thin and low-level, and C is the natural choice when it comes to communicating with an operating system API, or non-Swift libraries.</p>

<p>At a later stage, we’ll have to face the complications of distributing the Swift runtime, but having C at disposal may dramatically reduce the impact of third-party dependencies, including those Swift itself relies on. Let me anticipate a few examples:</p>

<ul>
  <li>The burden of Foundation, or even Concurrency, may be avoided with a tailored C API for our specific domain.</li>
  <li>The WireGuard backend, that Partout currently integrates via <a href="https://github.com/WireGuard/wireguard-go">wireguard-go</a>, can communicate with the Linux/Windows kernel module instead.</li>
  <li>If the footprint is important, the OpenSSL dependency may be replaced with OS APIs, or used in SwiftPM as a shared library. This is common on Linux.</li>
</ul>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpartout%2Fblob%2F66f3ed5c01c8d357a7b625a1067f19f368698124%2FPackage.swift%23L334-L346&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<h2 id="bottom-line">Bottom line</h2>

<p>C is a first-class citizen in the Swift ecosystem, and it’s the door to literally everything about a device. Keep enjoying the convenience of the modern Swift abstractions, but don’t fear the power of C when necessary, because C code compiles everywhere with little to no modifications. Some stuff is incredibly easier in C than Swift.</p>

<p>In the next article, I’ll show you how to survive the deceptive complexity of Swift/C bridging.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><summary type="html"><![CDATA[This is where the fun begins. Partout, the library I talk about in this series, is a networking library. As such, there are places where code control and performance are paramount. The integration of Swift with the C language for low-level routines is neat, and SwiftPM makes it very easy to mix Swift and C code as if they were the same thing. The dangers of Apple “Mix and Match” I said “mix Swift and C code”, but I should have said “Swift, C, and Objective-C code”. Given that Swift was born off the ribs of Objective-C and the everlasting NeXSTEP library –I know you love that ubiquitous NS prefix–, it still owes a big legacy to that system. Since the beginning, Apple offered great tools to make the migration from ObjC to Swift as seamless as possible. In fact, the process has been so smooth that you may have a hard time spotting the Objective-C entities of a Swift codebase. While this is amazing for Apple-oriented software with plenty of legacy, this is no less than a disgrace when you port Swift elsewhere, because Objective-C is not available to Swift out of the Apple ecosystem. At least, not easily at all. Embrace the power of C The mix-and-match transition to Swift may lead your codebase to a place where it’s very difficult to gauge the extent of the Objective-C legacy. Why is this important? Because if your intent is going cross-platform, you’d better port all your Objective-C code to good old C. The alternative is manually linking against GNUstep, but it’s niche GPL software, and adds unnecessary complexity to keep around a language that is already obsolete. In my case, the low-level part of my OpenVPN implementation in Partout was written in Objective-C plus OpenSSL, so I decided it was time to patiently write a new C version. You have no idea how thrilled I am that this new Swift/C implementation now works on Apple, Windows, Linux, and Android! It took me a couple of weeks to have a successful connection over the new code, and not only was it more pleasant (Objective-C is not praised for its beauty), it was also significantly faster. The image below shows a speed test comparing the performance of my C (1) and ObjC (2) implementations of the OpenVPN protocol over the same 5G connection. Can I finally mention the joy of using C again after years of high-level programming? Let countless options unfold As you dig into C interop, you realize how many things you can do with Swift in both an abstract and performant fashion. WWDC 2024 even introduced the Embedded Swift mode to really go thin and low-level, and C is the natural choice when it comes to communicating with an operating system API, or non-Swift libraries. At a later stage, we’ll have to face the complications of distributing the Swift runtime, but having C at disposal may dramatically reduce the impact of third-party dependencies, including those Swift itself relies on. Let me anticipate a few examples: The burden of Foundation, or even Concurrency, may be avoided with a tailored C API for our specific domain. The WireGuard backend, that Partout currently integrates via wireguard-go, can communicate with the Linux/Windows kernel module instead. If the footprint is important, the OpenSSL dependency may be replaced with OS APIs, or used in SwiftPM as a shared library. This is common on Linux. Bottom line C is a first-class citizen in the Swift ecosystem, and it’s the door to literally everything about a device. Keep enjoying the convenience of the modern Swift abstractions, but don’t fear the power of C when necessary, because C code compiles everywhere with little to no modifications. Some stuff is incredibly easier in C than Swift. In the next article, I’ll show you how to survive the deceptive complexity of Swift/C bridging.]]></summary></entry><entry><title type="html">Cross-platform Swift: Platform specifics</title><link href="https://davidederosa.com/cross-platform-swift/platform-specifics/" rel="alternate" type="text/html" title="Cross-platform Swift: Platform specifics" /><published>2025-06-30T00:00:00+02:00</published><updated>2025-06-30T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-platform-specifics</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/platform-specifics/"><![CDATA[<p>Very few developers treat the SwiftPM manifest, i.e. the <code class="language-plaintext highlighter-rouge">Package.swift</code> file, as what its extension suggests. If you are used to enumerate static products and targets, remember that the SwiftPM manifest is a fully legit Swift program, and as such it allows for plenty of control.</p>

<h2 id="conditionals-in-packageswift">Conditionals in Package.swift</h2>

<p>In a library whose aim is to target multiple platforms, and try different paths along the way, a flexible manifest is of great help. Partout uses generic Swift routines overall, but in some areas it needs to differentiate how things are done based on the platform it’s running on.</p>

<p>Think of:</p>

<ul>
  <li>DNS resolution (CFHost vs POSIX)</li>
  <li>Pseudo-random number generation (SecRandom vs getrandom)</li>
  <li>Access to the filesystem (FileManager vs FILE *)</li>
</ul>

<p>In some cases, even provide additional behavior that is not available on other platforms. If you started our Swift library on Apple platforms, like it’s often the case, you may have used plenty of frameworks that are tighly bound to Apple. Examples:</p>

<ul>
  <li>UserDefaults</li>
  <li>The keychain</li>
  <li>iCloud</li>
  <li>Camera</li>
  <li>…</li>
</ul>

<h2 id="building-on-non-apple">Building on non-Apple</h2>

<p>While it’s true that the <code class="language-plaintext highlighter-rouge">Foundation</code> framework may provide some platform-agnostic API (e.g. <code class="language-plaintext highlighter-rouge">UserDefaults</code>), it’s better to take full control of what’s being distributed based on our choices. If you care to split platform-specific code into separate targets, you can leverage the <code class="language-plaintext highlighter-rouge">condition</code> parameter of a dependency to fine-tune per-platform dependencies:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"SomeMultiCode"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"SomeiOSDep"</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">iOS</span><span class="p">])),</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"SomeWindowsDep"</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">windows</span><span class="p">])),</span>
        <span class="c1">// ...</span>
        <span class="c1">// same with .product</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Invoking <code class="language-plaintext highlighter-rouge">swift build --target &lt;some&gt;</code> will comply with the platform conditionals, whereas this (still) seems to be a problem for tests. That’s because SwiftPM attempts to build all targets regardless of the conditionals, then compose the filtered targets to assemble the final products, whereas it shouldn’t build some targets in the first place.</p>

<p>A mitigation for this problem is to wrap conditional code in a <code class="language-plaintext highlighter-rouge">canImport</code> condition:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// make sure that the import is available</span>
<span class="cp">#if canImport(Security)</span>
<span class="kd">import</span> <span class="kt">Security</span>

<span class="c1">// do stuff with the Apple Security framework</span>
<span class="cp">#endif</span>
</code></pre></div></div>

<p>This is acceptable inside the library, but how should consumers deal with all these inconvenient differences?</p>

<h2 id="dependency-factory">Dependency factory</h2>

<p>A simple solution to avoid conditionals in consumer apps is the use of a <em>factory</em> to instantiate the right dependencies for our environment. The factory would internally pick the suitable implementation for the current platform, lifting the burden of the choice from the user of the library.</p>

<p>Imagine that we want to provide a common interface for the persistent storage of the library. A natural choice on Apple would be Core Data, and maybe Realm or plain SQLite on Windows and Linux. Furthermore, we may want to support CloudKit synchronization on Apple devices, and omit that feature elsewhere.</p>

<p>In Package.swift:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyPersistence"</span>
<span class="p">),</span>
<span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyApplePersistence"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">"MyPersistence"</span><span class="p">]</span>
<span class="p">),</span>
<span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyOtherPersistence"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">"MyPersistence"</span><span class="p">]</span>
<span class="p">),</span>
<span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyLibrary"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"MyApplePersistence"</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">iOS</span><span class="p">,</span> <span class="o">.</span><span class="n">macOS</span><span class="p">,</span> <span class="o">.</span><span class="n">tvOS</span><span class="p">,</span> <span class="o">.</span><span class="n">watchOS</span><span class="p">])),</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"MyOtherPersistence"</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">windows</span><span class="p">,</span> <span class="o">.</span><span class="n">linux</span><span class="p">,</span> <span class="o">.</span><span class="n">android</span><span class="p">])),</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">MyPersistence</code> we declare the generic persistence API:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Persistence</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">supportsSynchronization</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="kd">func</span> <span class="n">save</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="k">throws</span>
<span class="p">}</span>
</code></pre></div></div>

<p>that we then implement in <code class="language-plaintext highlighter-rouge">CoreDataPersistence</code> with Core Data, in the <code class="language-plaintext highlighter-rouge">MyApplePersistence</code> target:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">CoreData</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">CoreDataPersistence</span><span class="p">:</span> <span class="kt">Persistence</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">supportsSynchronization</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">save</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and <code class="language-plaintext highlighter-rouge">RealmPersistence</code> with Realm, in the <code class="language-plaintext highlighter-rouge">MyOtherPersistence</code> target:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Realm</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">RealmPersistence</span><span class="p">:</span> <span class="kt">Persistence</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">supportsSynchronization</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="kc">false</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">save</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the <code class="language-plaintext highlighter-rouge">MyLibrary</code> umbrella target:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Factories</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">PersistenceFactory</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">newPersistence</span><span class="p">(</span><span class="n">at</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Persistence</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Factories</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">persistence</span> <span class="o">=</span> <span class="kt">PersistenceFactoryImpl</span><span class="p">()</span>
<span class="p">}</span>

<span class="cp">#if canImport(MyApplePersistence)</span>

<span class="c1">// uses Core Data</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">PersistenceFactoryImpl</span><span class="p">:</span> <span class="kt">PersistenceFactory</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">newPersistence</span><span class="p">(</span><span class="n">at</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Persistence</span> <span class="p">{</span>
        <span class="k">try</span> <span class="kt">CoreDataPersistence</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="n">path</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#elseif canImport(MyOtherPersistence)</span>

<span class="c1">// uses Realm</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">PersistenceFactoryImpl</span><span class="p">:</span> <span class="kt">PersistenceFactory</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">newPersistence</span><span class="p">(</span><span class="n">at</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Persistence</span> <span class="p">{</span>
        <span class="k">try</span> <span class="kt">RealmPersistence</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="n">path</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="c1">// unsupported platform</span>

<span class="cp">#endif</span>
</code></pre></div></div>

<p>Finally, in the consumer app we would do this regardless of the operating system:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">path</span> <span class="o">=</span> <span class="s">"SomeFile.db"</span>
    <span class="k">let</span> <span class="nv">persistence</span> <span class="o">=</span> <span class="kt">Factories</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="nf">newPersistence</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">path</span><span class="p">)</span>
    <span class="c1">// ...</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Supports synchronization: </span><span class="se">\(</span><span class="n">persistence</span><span class="o">.</span><span class="n">supportsSynchronization</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">persistence</span><span class="o">.</span><span class="nf">save</span><span class="p">(</span><span class="s">"SomeString"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The library would just take care of the different implementations.</p>

<h2 id="bottom-line">Bottom line</h2>

<p>It’s easy to overcome the platform differences with SwiftPM conditionals and simple design patterns. If you need even more customizations, don’t be afraid to tweak the manifest further because it’s good old Swift, not static YAML. Even just an <code class="language-plaintext highlighter-rouge">if</code>, or reading environment variables with <a href="https://developer.apple.com/documentation/foundation/processinfo"><code class="language-plaintext highlighter-rouge">ProcessInfo</code></a>, may do wonders and resolve convoluted dynamic package layouts. Yes, in <code class="language-plaintext highlighter-rouge">FOOBAR="value" swift build</code>, the <code class="language-plaintext highlighter-rouge">FOOBAR</code> variable is reachable from your manifest!</p>

<p>In the next article, we’ll start the long but inevitable journey of Swift interoperability with C and other languages.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><summary type="html"><![CDATA[Very few developers treat the SwiftPM manifest, i.e. the Package.swift file, as what its extension suggests. If you are used to enumerate static products and targets, remember that the SwiftPM manifest is a fully legit Swift program, and as such it allows for plenty of control. Conditionals in Package.swift In a library whose aim is to target multiple platforms, and try different paths along the way, a flexible manifest is of great help. Partout uses generic Swift routines overall, but in some areas it needs to differentiate how things are done based on the platform it’s running on. Think of: DNS resolution (CFHost vs POSIX) Pseudo-random number generation (SecRandom vs getrandom) Access to the filesystem (FileManager vs FILE *) In some cases, even provide additional behavior that is not available on other platforms. If you started our Swift library on Apple platforms, like it’s often the case, you may have used plenty of frameworks that are tighly bound to Apple. Examples: UserDefaults The keychain iCloud Camera … Building on non-Apple While it’s true that the Foundation framework may provide some platform-agnostic API (e.g. UserDefaults), it’s better to take full control of what’s being distributed based on our choices. If you care to split platform-specific code into separate targets, you can leverage the condition parameter of a dependency to fine-tune per-platform dependencies: .target( name: "SomeMultiCode", dependencies: [ .target(name: "SomeiOSDep", condition: .when(platforms: [.iOS])), .target(name: "SomeWindowsDep", condition: .when(platforms: [.windows])), // ... // same with .product ] ) Invoking swift build --target &lt;some&gt; will comply with the platform conditionals, whereas this (still) seems to be a problem for tests. That’s because SwiftPM attempts to build all targets regardless of the conditionals, then compose the filtered targets to assemble the final products, whereas it shouldn’t build some targets in the first place. A mitigation for this problem is to wrap conditional code in a canImport condition: // make sure that the import is available #if canImport(Security) import Security // do stuff with the Apple Security framework #endif This is acceptable inside the library, but how should consumers deal with all these inconvenient differences? Dependency factory A simple solution to avoid conditionals in consumer apps is the use of a factory to instantiate the right dependencies for our environment. The factory would internally pick the suitable implementation for the current platform, lifting the burden of the choice from the user of the library. Imagine that we want to provide a common interface for the persistent storage of the library. A natural choice on Apple would be Core Data, and maybe Realm or plain SQLite on Windows and Linux. Furthermore, we may want to support CloudKit synchronization on Apple devices, and omit that feature elsewhere. In Package.swift: .target( name: "MyPersistence" ), .target( name: "MyApplePersistence", dependencies: ["MyPersistence"] ), .target( name: "MyOtherPersistence", dependencies: ["MyPersistence"] ), .target( name: "MyLibrary", dependencies: [ .target(name: "MyApplePersistence", condition: .when(platforms: [.iOS, .macOS, .tvOS, .watchOS])), .target(name: "MyOtherPersistence", condition: .when(platforms: [.windows, .linux, .android])), ] ) In MyPersistence we declare the generic persistence API: public protocol Persistence { var supportsSynchronization: Bool { get } func save&lt;T&gt;(_ object: T) throws } that we then implement in CoreDataPersistence with Core Data, in the MyApplePersistence target: import CoreData public final class CoreDataPersistence: Persistence { init(path: String) { // ... } var supportsSynchronization: Bool { true } func save&lt;T&gt;(_ object: T) throws { // ... } } and RealmPersistence with Realm, in the MyOtherPersistence target: import Realm public final class RealmPersistence: Persistence { init(path: String) { // ... } var supportsSynchronization: Bool { false } func save&lt;T&gt;(_ object: T) throws { // ... } } In the MyLibrary umbrella target: public enum Factories { } public protocol PersistenceFactory { func newPersistence(at path: String) throws -&gt; Persistence } extension Factories { public static let persistence = PersistenceFactoryImpl() } #if canImport(MyApplePersistence) // uses Core Data private final class PersistenceFactoryImpl: PersistenceFactory { func newPersistence(at path: String) throws -&gt; Persistence { try CoreDataPersistence(path: path) } } #elseif canImport(MyOtherPersistence) // uses Realm private final class PersistenceFactoryImpl: PersistenceFactory { func newPersistence(at path: String) throws -&gt; Persistence { try RealmPersistence(path: path) } } #else // unsupported platform #endif Finally, in the consumer app we would do this regardless of the operating system: func someFunction() { let path = "SomeFile.db" let persistence = Factories.persistence.newPersistence(at: path) // ... do { print("Supports synchronization: \(persistence.supportsSynchronization)") try persistence.save("SomeString") } catch { // ... } } The library would just take care of the different implementations. Bottom line It’s easy to overcome the platform differences with SwiftPM conditionals and simple design patterns. If you need even more customizations, don’t be afraid to tweak the manifest further because it’s good old Swift, not static YAML. Even just an if, or reading environment variables with ProcessInfo, may do wonders and resolve convoluted dynamic package layouts. Yes, in FOOBAR="value" swift build, the FOOBAR variable is reachable from your manifest! In the next article, we’ll start the long but inevitable journey of Swift interoperability with C and other languages.]]></summary></entry><entry><title type="html">A true case for Dependency Injection</title><link href="https://davidederosa.com/2025/05/a-true-case-for-dependency-injection/" rel="alternate" type="text/html" title="A true case for Dependency Injection" /><published>2025-05-24T00:00:00+02:00</published><updated>2025-05-24T00:00:00+02:00</updated><id>https://davidederosa.com/2025/05/a-true-case-for-dependency-injection</id><content type="html" xml:base="https://davidederosa.com/2025/05/a-true-case-for-dependency-injection/"><![CDATA[<p>When studying the foundations of a programming language, for example, during a career in Computer Science, very rarely are <em>design patterns</em> and the concept of <em>software architecture</em> presented in a way that can be transferred to real-world scenarios. Add to that, you may never use most of the well-known patterns, and it’s okay because you don’t want to be a hammer looking for a nail. You shouldn’t force a design pattern for the sake of using it.</p>

<p><a href="#how-di-helps-me-scale-passepartout">Below</a>, I’ll show you how a popular design pattern helped me rework Passepartout for Mac to distribute it <a href="https://github.com/passepartoutvpn/passepartout/issues/231">outside of the App Store</a>, without messing too much with the existing and stable codebase.</p>

<h3 id="experience-produces-patterns">Experience produces patterns</h3>

<p>Patterns are simply an outcome of your programming experience, in that you recognize a common problem for which a common solution also exists. Yet, the amount of buzzwords in the online communities around what some erroneously call “architectures” is ridiculous –the MVVM acronym being the one I stand the least–, to the point that the poor newcomers may feel intimidated. The risk of being ostracized for not using “the right name for the thing” is real, even if the same thing could be named differently the moment you visit a different community.</p>

<p>But hey, listen, the reality is brighter: compilers don’t give a damn about the name you give to your grand architectures. The only names that matter, at the end of the day, are those coming from the syntax of the programming language you use.</p>

<h3 id="popular-design-patterns">Popular design patterns</h3>

<p>Nevertheless, some design patterns are so popular that their names are <em>de facto</em> universal:</p>

<ul>
  <li><a href="https://refactoring.guru/design-patterns/builder">Builder</a></li>
  <li><a href="https://refactoring.guru/design-patterns/command">Command</a></li>
  <li><a href="https://refactoring.guru/design-patterns/factory-method">Factory</a></li>
  <li><a href="https://refactoring.guru/design-patterns/singleton">Singleton</a></li>
  <li><a href="https://refactoring.guru/design-patterns/strategy">Strategy</a></li>
  <li>…</li>
</ul>

<p>You’re bound to cross them at least once in your lifetime. If you like practice more than theory, you definitely used any of the above without the need to give them a name. These patterns are undoubtly useful, they resolve basic architectural problems and, contrary to some beliefs, by no means are they tied to OOP.</p>

<p>Then there is <em>Dependency Injection</em> (DI). I hate giving this one a name, but there it is. More than a design pattern, DI is an <em>approach</em> to making software. I call it that way to avoid the terrible mistake of thinking that there is only one way to do it. I mean, if you’re a Java programmer, you don’t need the <a href="https://spring.io/projects/spring-framework">Spring Framework</a> to do DI.</p>

<p>Here’s how I like to phrase it: <strong>DI is the act of decoupling your software from the underlying implementations of its dependencies.</strong></p>

<h3 id="how-di-helps-me-scale-passepartout">How DI helps me scale Passepartout</h3>

<p>Weeks ago, I decided to make Passepartout for Mac available <a href="https://github.com/passepartoutvpn/passepartout/issues/231">outside of the App Store</a>. Making such a VPN app standalone is no trivial task because the way it operates is radically different: the UI is still a frontend to the VPN backend, but the app and the VPN processes execute as different users, and they do not easily communicate. Specifically, the VPN is deployed as <a href="apple-sysex">System Extension</a>, and therefore runs as <code class="language-plaintext highlighter-rouge">root</code>.</p>

<p>By leaving the App Store, I was about to lose a big chunk of features:</p>

<ul>
  <li>App Groups: required for app/VPN IPC (inter-process communication), data sharing, and logs</li>
  <li>Shared keychain: used to persist the VPN profiles</li>
  <li>In-app purchases</li>
  <li>iCloud</li>
</ul>

<p>In-app purchases and iCloud could be postponed by stripping paid features, but the core functionality of Passepartout relied on both App Groups and the shared keychain. I hit a tough blocker.</p>

<p>Here’s where DI comes to the rescue: <strong>you don’t change the business logic of your software</strong>, you rather change <em>how</em> that logic is implemented deep down in the leaves of the dependency tree. I still wanted to “share data between the app and the VPN process” (business logic), but I needed to change <em>how</em> that data was shared (dependency). Remember, this isolation is only possible if the two concerns are sharply separated, but this is the core principle behind DI.</p>

<p>The core library of Passepartout, <em>Partout,</em> is 100% pure Swift for this reason: the logic of the library is always the same, with the “low-level” implementations abstracted as <code class="language-plaintext highlighter-rouge">protocol</code>s, and for which the app is free to provide (inject) <em>truly</em> different implementations. In my case, it turned out that I could just craft new implementations for the standalone Mac app, whereas anything else would stay untouched.</p>

<h3 id="swap-out-the-broken-pieces">Swap out the broken pieces</h3>

<p>The process is fairly simple:</p>

<ul>
  <li>For each dependency, identify the “broken” implementation of a <code class="language-plaintext highlighter-rouge">protocol</code></li>
  <li>Write a new implementation, compatible with the target</li>
  <li>Unit test behavior as per the <code class="language-plaintext highlighter-rouge">protocol</code> pre/post conditions</li>
  <li>Swap the unsupported implementation with the new one</li>
</ul>

<p>After these steps, passing the tests would imply that the app will work like before, but regardless of being downloaded from the App Store or not. I can’t tell how thrilling it is when you see the magic of programming in action. This is a real-world situation where good practices and constant refactoring pay off.</p>

<p>The new Mac app eventually works around the missing functionalities by dynamically replacing (<code class="language-plaintext highlighter-rouge">supportsAppGroups</code> is false in this case):</p>

<ul>
  <li><a href="https://github.com/passepartoutvpn/partout/blob/master/Sources/Platforms/Apple/UserDefaultsEnvironment.swift"><code class="language-plaintext highlighter-rouge">UserDefaultsEnvironment</code></a> with <a href="https://github.com/passepartoutvpn/partout/blob/master/Sources/Platforms/AppleNE/App/NETunnelEnvironment.swift"><code class="language-plaintext highlighter-rouge">NETunnelEnvironment</code></a>, which does IPC by sending messages to the System Extension, rather than sharing data through the App Group <code class="language-plaintext highlighter-rouge">UserDefaults</code>. They both implement the <code class="language-plaintext highlighter-rouge">TunnelEnvironmentReader</code> protocol, meant for reading VPN data from the app.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">TunnelEnvironmentReader</span><span class="p">:</span> <span class="kt">Sendable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">environmentValue</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">TunnelEnvironmentKey</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Decodable</span>
<span class="p">}</span>
</code></pre></div></div>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpassepartout%2Fblob%2F7ffe37ea0d9e280b7cafbeff1332d431173be2d4%2FPassepartout%2FShared%2FDependencies%252BPartout.swift%23L59-L76&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<ul>
  <li><a href="https://github.com/passepartoutvpn/partout/blob/master/Sources/Platforms/AppleNE/Serialization/KeychainNEProtocolCoder.swift"><code class="language-plaintext highlighter-rouge">KeychainNEProtocolCoder</code></a> with <a href="https://github.com/passepartoutvpn/partout/blob/master/Sources/Platforms/AppleNE/Serialization/ProviderNEProtocolCoder.swift"><code class="language-plaintext highlighter-rouge">ProviderNEProtocolCoder</code></a>, which installs the VPN profiles without the keychain, using the Network Extension map in <code class="language-plaintext highlighter-rouge">providerConfiguration</code>. They both implement the <code class="language-plaintext highlighter-rouge">NEProtocolCoder</code> protocol, meant for VPN profiles serialization.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">NEProtocolCoder</span><span class="p">:</span> <span class="kt">Sendable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">protocolConfiguration</span><span class="p">(</span><span class="n">from</span> <span class="nv">profile</span><span class="p">:</span> <span class="kt">Profile</span><span class="p">,</span> <span class="nv">title</span><span class="p">:</span> <span class="p">(</span><span class="kt">Profile</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">NETunnelProviderProtocol</span>

    <span class="kd">func</span> <span class="nf">profile</span><span class="p">(</span><span class="n">from</span> <span class="nv">protocolConfiguration</span><span class="p">:</span> <span class="kt">NETunnelProviderProtocol</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Profile</span>
<span class="p">}</span>
</code></pre></div></div>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpassepartout%2Fblob%2F7ffe37ea0d9e280b7cafbeff1332d431173be2d4%2FPassepartout%2FShared%2FDependencies%252BPartout.swift%23L40-L57&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<h3 id="do-you-really-need-di">Do you really need DI?</h3>

<p>You’d better follow the DI approach early in your software development, but not immediately, because you may never need to convert a code module into a pluggable dependency. If you foresee that your software will scale enough to justify such an abstraction, then start pulling out third parties from your concrete classes.</p>

<p>By the way, in many corporate projects people use DI because “everybody does”, rather than understanding the real benefits and tradeoffs. The overhead of maintaining abstract layers, or even third parties, for entities that will <em>always</em> have one implementation is sadly laughable. Please, do not avoid concrete classes just because you read that on some book. As I said in the beginning, you shouldn’t use a solution for a problem you don’t have, and most projects don’t need bulky external third parties to deal with their trivial dependencies. If you wasted hours to track down the order and lifecycle of the objects that an app creates on launch, you know what I’m talking about.</p>

<p>Sometimes, it really seems that some modern programmers don’t know how to initialize objects in the first place. In that case, rather than a dependency injection engine –whatever that means–, why not go back to the basics?</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="dependency injection" /><summary type="html"><![CDATA[When studying the foundations of a programming language, for example, during a career in Computer Science, very rarely are design patterns and the concept of software architecture presented in a way that can be transferred to real-world scenarios. Add to that, you may never use most of the well-known patterns, and it’s okay because you don’t want to be a hammer looking for a nail. You shouldn’t force a design pattern for the sake of using it. Below, I’ll show you how a popular design pattern helped me rework Passepartout for Mac to distribute it outside of the App Store, without messing too much with the existing and stable codebase. Experience produces patterns Patterns are simply an outcome of your programming experience, in that you recognize a common problem for which a common solution also exists. Yet, the amount of buzzwords in the online communities around what some erroneously call “architectures” is ridiculous –the MVVM acronym being the one I stand the least–, to the point that the poor newcomers may feel intimidated. The risk of being ostracized for not using “the right name for the thing” is real, even if the same thing could be named differently the moment you visit a different community. But hey, listen, the reality is brighter: compilers don’t give a damn about the name you give to your grand architectures. The only names that matter, at the end of the day, are those coming from the syntax of the programming language you use. Popular design patterns Nevertheless, some design patterns are so popular that their names are de facto universal: Builder Command Factory Singleton Strategy … You’re bound to cross them at least once in your lifetime. If you like practice more than theory, you definitely used any of the above without the need to give them a name. These patterns are undoubtly useful, they resolve basic architectural problems and, contrary to some beliefs, by no means are they tied to OOP. Then there is Dependency Injection (DI). I hate giving this one a name, but there it is. More than a design pattern, DI is an approach to making software. I call it that way to avoid the terrible mistake of thinking that there is only one way to do it. I mean, if you’re a Java programmer, you don’t need the Spring Framework to do DI. Here’s how I like to phrase it: DI is the act of decoupling your software from the underlying implementations of its dependencies. How DI helps me scale Passepartout Weeks ago, I decided to make Passepartout for Mac available outside of the App Store. Making such a VPN app standalone is no trivial task because the way it operates is radically different: the UI is still a frontend to the VPN backend, but the app and the VPN processes execute as different users, and they do not easily communicate. Specifically, the VPN is deployed as System Extension, and therefore runs as root. By leaving the App Store, I was about to lose a big chunk of features: App Groups: required for app/VPN IPC (inter-process communication), data sharing, and logs Shared keychain: used to persist the VPN profiles In-app purchases iCloud In-app purchases and iCloud could be postponed by stripping paid features, but the core functionality of Passepartout relied on both App Groups and the shared keychain. I hit a tough blocker. Here’s where DI comes to the rescue: you don’t change the business logic of your software, you rather change how that logic is implemented deep down in the leaves of the dependency tree. I still wanted to “share data between the app and the VPN process” (business logic), but I needed to change how that data was shared (dependency). Remember, this isolation is only possible if the two concerns are sharply separated, but this is the core principle behind DI. The core library of Passepartout, Partout, is 100% pure Swift for this reason: the logic of the library is always the same, with the “low-level” implementations abstracted as protocols, and for which the app is free to provide (inject) truly different implementations. In my case, it turned out that I could just craft new implementations for the standalone Mac app, whereas anything else would stay untouched. Swap out the broken pieces The process is fairly simple: For each dependency, identify the “broken” implementation of a protocol Write a new implementation, compatible with the target Unit test behavior as per the protocol pre/post conditions Swap the unsupported implementation with the new one After these steps, passing the tests would imply that the app will work like before, but regardless of being downloaded from the App Store or not. I can’t tell how thrilling it is when you see the magic of programming in action. This is a real-world situation where good practices and constant refactoring pay off. The new Mac app eventually works around the missing functionalities by dynamically replacing (supportsAppGroups is false in this case): UserDefaultsEnvironment with NETunnelEnvironment, which does IPC by sending messages to the System Extension, rather than sharing data through the App Group UserDefaults. They both implement the TunnelEnvironmentReader protocol, meant for reading VPN data from the app. public protocol TunnelEnvironmentReader: Sendable { func environmentValue&lt;T&gt;(forKey key: TunnelEnvironmentKey&lt;T&gt;) -&gt; T? where T: Decodable } KeychainNEProtocolCoder with ProviderNEProtocolCoder, which installs the VPN profiles without the keychain, using the Network Extension map in providerConfiguration. They both implement the NEProtocolCoder protocol, meant for VPN profiles serialization. public protocol NEProtocolCoder: Sendable { func protocolConfiguration(from profile: Profile, title: (Profile) -&gt; String) throws -&gt; NETunnelProviderProtocol func profile(from protocolConfiguration: NETunnelProviderProtocol) throws -&gt; Profile } Do you really need DI? You’d better follow the DI approach early in your software development, but not immediately, because you may never need to convert a code module into a pluggable dependency. If you foresee that your software will scale enough to justify such an abstraction, then start pulling out third parties from your concrete classes. By the way, in many corporate projects people use DI because “everybody does”, rather than understanding the real benefits and tradeoffs. The overhead of maintaining abstract layers, or even third parties, for entities that will always have one implementation is sadly laughable. Please, do not avoid concrete classes just because you read that on some book. As I said in the beginning, you shouldn’t use a solution for a problem you don’t have, and most projects don’t need bulky external third parties to deal with their trivial dependencies. If you wasted hours to track down the order and lifecycle of the objects that an app creates on launch, you know what I’m talking about. Sometimes, it really seems that some modern programmers don’t know how to initialize objects in the first place. In that case, rather than a dependency injection engine –whatever that means–, why not go back to the basics?]]></summary></entry><entry><title type="html">Cross-platform Swift: Core libraries</title><link href="https://davidederosa.com/cross-platform-swift/core-libraries/" rel="alternate" type="text/html" title="Cross-platform Swift: Core libraries" /><published>2025-05-05T00:00:00+02:00</published><updated>2025-05-05T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-core-libraries</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/core-libraries/"><![CDATA[<p>When programming Swift in Xcode, we take for granted a few things that are in fact different when you compile on other platforms. Here I show you those I stumbled upon, and how I worked around some limitations of the bare Swift toolchain.</p>

<h2 id="foundation">Foundation</h2>

<p>Have you ever compiled Swift code without importing <a href="https://developer.apple.com/documentation/foundation/"><code class="language-plaintext highlighter-rouge">Foundation</code></a>? Do you even think it’s possible? Look at the most basic Swift template in Xcode:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  File.swift</span>
<span class="c1">//  Passepartout</span>
<span class="c1">//</span>
<span class="c1">//  Created by Davide De Rosa on 5/5/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">Foundation</span>
</code></pre></div></div>

<p>which in Objective-C would be:</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  File.m</span>
<span class="c1">//  Passepartout</span>
<span class="c1">//</span>
<span class="c1">//  Created by Davide De Rosa on 5/5/25.</span>
<span class="c1">//</span>

<span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span></code></pre></div></div>

<p>Let’s cut it short to the bad news: <strong><code class="language-plaintext highlighter-rouge">Foundation</code> is not part of the Swift language</strong>.</p>

<p><code class="language-plaintext highlighter-rouge">Foundation</code> is, however, available as an import in the prebuilt Swift toolchains for non-Apple platforms. Why is that? Over the years, those pseudo-implicit imports may have convinced most of us that <code class="language-plaintext highlighter-rouge">Foundation</code> has always been a standard library. First, as an Objective-C wrapper of <a href="https://developer.apple.com/documentation/corefoundation/"><code class="language-plaintext highlighter-rouge">CoreFoundation</code></a>. Later, as an integral part of Swift.</p>

<p>The maintainers of the otherwise modern Apple language are well aware of this heavy legacy, so they created a replacement for <code class="language-plaintext highlighter-rouge">Foundation</code> that is not bound to the Apple SDK. Beware that if you build the Swift toolchain by yourself, <code class="language-plaintext highlighter-rouge">Foundation</code> is not included by default. This tells me that maybe, <em>maybe</em>, <code class="language-plaintext highlighter-rouge">Foundation</code> will also depart from Swift someday. You were warned.</p>

<p>Below are a few <code class="language-plaintext highlighter-rouge">Foundation</code> entities that many developers are familiar with:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Data</code> for binary data (bridging ObjC <code class="language-plaintext highlighter-rouge">NSData</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">Date</code> for dates and timestamps (briding ObjC <code class="language-plaintext highlighter-rouge">NSDate</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">UUID</code> for unique identifiers</li>
  <li><code class="language-plaintext highlighter-rouge">JSONEncoder</code> and <code class="language-plaintext highlighter-rouge">JSONDecoder</code> (these are pure Swift)</li>
  <li><code class="language-plaintext highlighter-rouge">URL</code>, <code class="language-plaintext highlighter-rouge">URLSession</code> and tasks (bridigng ObjC <code class="language-plaintext highlighter-rouge">NSURL</code> and <code class="language-plaintext highlighter-rouge">NSURLSession</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">FileManager</code></li>
  <li>A bunch of other <code class="language-plaintext highlighter-rouge">NS</code>-prefixed stuff</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">Foundation</code> import is not as a comprehensive as on Apple. This new version has opt-in modules due to the dependencies that they imply:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FoundationNetworking</code> for <code class="language-plaintext highlighter-rouge">URL</code> and <code class="language-plaintext highlighter-rouge">URLSession</code>, due to the dependency on <code class="language-plaintext highlighter-rouge">libcurl</code></li>
  <li><code class="language-plaintext highlighter-rouge">FoundationXML</code> for <code class="language-plaintext highlighter-rouge">XMLParser</code>, due to the dependency on <code class="language-plaintext highlighter-rouge">libxml2</code></li>
</ul>

<p>Can you get rid of all this stuff already? I doubt you can, unless you started a new project knowing these gotchas beforehand. In my case, I need to keep the burden of this non-standard library, at least until Swift will have a richer standard library.</p>

<p>Last but not least, <code class="language-plaintext highlighter-rouge">Foundation</code> comes with the <a href="https://developer.apple.com/documentation/dispatch">Grand Central Dispatch</a> API, but listen to me: it’s time you learn <a href="https://developer.apple.com/documentation/swift/concurrency"><code class="language-plaintext highlighter-rouge">Concurrency</code></a>.</p>

<h2 id="swift-standard-library">Swift standard library</h2>

<p>You heard that, Swift has a <a href="https://developer.apple.com/documentation/swift/swift-standard-library"><em>standard library</em></a>, but few would be able to delineate its boundaries. The Apple documentation certainly doesn’t help when figuring out what comes from the language, and what comes from <code class="language-plaintext highlighter-rouge">Foundation</code>.</p>

<p>A partial list:</p>

<ul>
  <li>Primitive types: <code class="language-plaintext highlighter-rouge">Bool</code>, <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">Double</code>, …, but <em>not</em> <code class="language-plaintext highlighter-rouge">Data</code> or <code class="language-plaintext highlighter-rouge">Date</code>!</li>
  <li>Protocols: <code class="language-plaintext highlighter-rouge">Comparable</code>, <code class="language-plaintext highlighter-rouge">Equatable</code>, <code class="language-plaintext highlighter-rouge">Hashable</code>, <code class="language-plaintext highlighter-rouge">Identifiable</code>, <code class="language-plaintext highlighter-rouge">Codable</code>, …</li>
  <li>Collections: <code class="language-plaintext highlighter-rouge">Array</code>, <code class="language-plaintext highlighter-rouge">Dictionary</code>, <code class="language-plaintext highlighter-rouge">Set</code>, <code class="language-plaintext highlighter-rouge">Collection</code>, …</li>
  <li>Flow constructs: <code class="language-plaintext highlighter-rouge">Result</code>, <code class="language-plaintext highlighter-rouge">Error</code></li>
  <li>String description protocols: <code class="language-plaintext highlighter-rouge">CustomStringConvertible</code> and variations</li>
</ul>

<p>Thank God, <code class="language-plaintext highlighter-rouge">Concurrency</code> is also part of the library.</p>

<h2 id="platform-specific-packages">Platform-specific packages</h2>

<p>When developing on macOS, you may notice that standard C functions are implicitly bridged to Swift code. This autocompletion is proof:</p>

<p><img src="/s/f/cross-platform-swift/core-libraries-xcode-c-autocompletion.png" alt="C autocompletion of memcpy in Xcode" /></p>

<p>The other Swift environments behave differently, and honestly, I prefer it that way. I’d rather import things explicitly when needed. Therefore, the compiler will stop at C symbols in Swift code out of the box. Windows in particular doesn’t follow the POSIX naming, and some symbols come from very differently named headers. For example, the first symbol that triggered a compiler failure for me was <code class="language-plaintext highlighter-rouge">AF_INET</code>, which on Windows is part of <code class="language-plaintext highlighter-rouge">WinSock2.h</code>.</p>

<p>While the header names are relevant in C code, Swift remains a bit more agnostic by hiding them behind platform-specific packages:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">import WinSDK</code> on Windows</li>
  <li><code class="language-plaintext highlighter-rouge">import Linux</code> on Linux</li>
  <li><code class="language-plaintext highlighter-rouge">import Android</code> on Android</li>
</ul>

<p>The imports still require some <code class="language-plaintext highlighter-rouge">#if</code> conditionals here and there. At that point, you may run into a few C symbols that are only available on Apple platforms, like any variation of <code class="language-plaintext highlighter-rouge">NSEC_PER_*</code> in my library. In that case, you can redefine those symbols yourself, or refactor the code to not use them at all.</p>

<p>Another thing I noticed is name clashes. To name one, Windows seems to have a name clash on <code class="language-plaintext highlighter-rouge">UUID</code> (alias for <code class="language-plaintext highlighter-rouge">GUID</code> in Win32), which I resolved this way:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if os(Windows)</span>
<span class="kd">import</span> <span class="kt">WinSDK</span>
<span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">UUID</span> <span class="o">=</span> <span class="kt">Foundation</span><span class="o">.</span><span class="kt">UUID</span>
<span class="cp">#endif</span>
</code></pre></div></div>

<p>There might be more similar occurrences, but you can get around them with conditionals and forced <code class="language-plaintext highlighter-rouge">typealias</code>. If you know better ways, please leave a comment below the post.</p>

<h2 id="objective-c-runtime">Objective-C runtime</h2>

<p>The need for the Objective-C runtime in your Swift code may be incredibly subtle. Look at a linker error I faced:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lld-link: error: undefined symbol: objc_autoreleaseReturnValue
</code></pre></div></div>

<p>I was lucky to catch the issue in a place where the compiler could not provide any hint. The culprit was a class of the Partout API that was using the <a href="https://developer.apple.com/documentation/javascriptcore"><code class="language-plaintext highlighter-rouge">JavaScriptCore</code></a> framework, which in turn required Swift closures to be Objective-C blocks to inject custom functions into the JavaScript code. If you’ve never seen that, here’s a bit of the offending code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">inject</span><span class="p">(</span><span class="s">"getText"</span><span class="p">,</span> <span class="nv">object</span><span class="p">:</span> <span class="n">vm</span><span class="o">.</span><span class="n">getText</span> <span class="k">as</span> <span class="kd">@convention</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">(</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Any</span><span class="p">?)</span>
</code></pre></div></div>

<p>Frankly, I wondered why the code compiled at all, so I tried to put <code class="language-plaintext highlighter-rouge">@objc</code> on top of a Swift class on Linux:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>File.swift:1:2: error: Objective-C interoperability is disabled
</code></pre></div></div>

<p>Gosh, then why does <code class="language-plaintext highlighter-rouge">@convention(block)</code> compile on non-Apple, if the linker is always bound to fail? I have no idea, but look at your code carefully if it compiles fine but the linker complains about some Objective-C runtime or obscure <code class="language-plaintext highlighter-rouge">NS*</code> entity.</p>

<p>Fun fact: <code class="language-plaintext highlighter-rouge">JavaScriptCore</code> is an Objective-C framework with iOS 16 as the <em>minimum target</em>, which deceived me into seeing it as a “new thing”.</p>

<h2 id="bottom-line">Bottom line</h2>

<p>Stick with pure Swift as much as you can, and when you use <code class="language-plaintext highlighter-rouge">Foundation</code>, do it with a grain of salt: the Swift standard library is much smaller than you think. Spot any Objective-C sorcery, and kill it for good.</p>

<p>In the next article, I will show you how conditionals and dependency injection allows us to still use frameworks that are not available on all platforms.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><summary type="html"><![CDATA[When programming Swift in Xcode, we take for granted a few things that are in fact different when you compile on other platforms. Here I show you those I stumbled upon, and how I worked around some limitations of the bare Swift toolchain. Foundation Have you ever compiled Swift code without importing Foundation? Do you even think it’s possible? Look at the most basic Swift template in Xcode: // // File.swift // Passepartout // // Created by Davide De Rosa on 5/5/25. // import Foundation which in Objective-C would be: // // File.m // Passepartout // // Created by Davide De Rosa on 5/5/25. // #import &lt;Foundation/Foundation.h&gt; Let’s cut it short to the bad news: Foundation is not part of the Swift language. Foundation is, however, available as an import in the prebuilt Swift toolchains for non-Apple platforms. Why is that? Over the years, those pseudo-implicit imports may have convinced most of us that Foundation has always been a standard library. First, as an Objective-C wrapper of CoreFoundation. Later, as an integral part of Swift. The maintainers of the otherwise modern Apple language are well aware of this heavy legacy, so they created a replacement for Foundation that is not bound to the Apple SDK. Beware that if you build the Swift toolchain by yourself, Foundation is not included by default. This tells me that maybe, maybe, Foundation will also depart from Swift someday. You were warned. Below are a few Foundation entities that many developers are familiar with: Data for binary data (bridging ObjC NSData) Date for dates and timestamps (briding ObjC NSDate) UUID for unique identifiers JSONEncoder and JSONDecoder (these are pure Swift) URL, URLSession and tasks (bridigng ObjC NSURL and NSURLSession) FileManager A bunch of other NS-prefixed stuff The Foundation import is not as a comprehensive as on Apple. This new version has opt-in modules due to the dependencies that they imply: FoundationNetworking for URL and URLSession, due to the dependency on libcurl FoundationXML for XMLParser, due to the dependency on libxml2 Can you get rid of all this stuff already? I doubt you can, unless you started a new project knowing these gotchas beforehand. In my case, I need to keep the burden of this non-standard library, at least until Swift will have a richer standard library. Last but not least, Foundation comes with the Grand Central Dispatch API, but listen to me: it’s time you learn Concurrency. Swift standard library You heard that, Swift has a standard library, but few would be able to delineate its boundaries. The Apple documentation certainly doesn’t help when figuring out what comes from the language, and what comes from Foundation. A partial list: Primitive types: Bool, Int, String, Double, …, but not Data or Date! Protocols: Comparable, Equatable, Hashable, Identifiable, Codable, … Collections: Array, Dictionary, Set, Collection, … Flow constructs: Result, Error String description protocols: CustomStringConvertible and variations Thank God, Concurrency is also part of the library. Platform-specific packages When developing on macOS, you may notice that standard C functions are implicitly bridged to Swift code. This autocompletion is proof: The other Swift environments behave differently, and honestly, I prefer it that way. I’d rather import things explicitly when needed. Therefore, the compiler will stop at C symbols in Swift code out of the box. Windows in particular doesn’t follow the POSIX naming, and some symbols come from very differently named headers. For example, the first symbol that triggered a compiler failure for me was AF_INET, which on Windows is part of WinSock2.h. While the header names are relevant in C code, Swift remains a bit more agnostic by hiding them behind platform-specific packages: import WinSDK on Windows import Linux on Linux import Android on Android The imports still require some #if conditionals here and there. At that point, you may run into a few C symbols that are only available on Apple platforms, like any variation of NSEC_PER_* in my library. In that case, you can redefine those symbols yourself, or refactor the code to not use them at all. Another thing I noticed is name clashes. To name one, Windows seems to have a name clash on UUID (alias for GUID in Win32), which I resolved this way: #if os(Windows) import WinSDK public typealias UUID = Foundation.UUID #endif There might be more similar occurrences, but you can get around them with conditionals and forced typealias. If you know better ways, please leave a comment below the post. Objective-C runtime The need for the Objective-C runtime in your Swift code may be incredibly subtle. Look at a linker error I faced: lld-link: error: undefined symbol: objc_autoreleaseReturnValue I was lucky to catch the issue in a place where the compiler could not provide any hint. The culprit was a class of the Partout API that was using the JavaScriptCore framework, which in turn required Swift closures to be Objective-C blocks to inject custom functions into the JavaScript code. If you’ve never seen that, here’s a bit of the offending code: inject("getText", object: vm.getText as @convention(block) (String) -&gt; Any?) Frankly, I wondered why the code compiled at all, so I tried to put @objc on top of a Swift class on Linux: File.swift:1:2: error: Objective-C interoperability is disabled Gosh, then why does @convention(block) compile on non-Apple, if the linker is always bound to fail? I have no idea, but look at your code carefully if it compiles fine but the linker complains about some Objective-C runtime or obscure NS* entity. Fun fact: JavaScriptCore is an Objective-C framework with iOS 16 as the minimum target, which deceived me into seeing it as a “new thing”. Bottom line Stick with pure Swift as much as you can, and when you use Foundation, do it with a grain of salt: the Swift standard library is much smaller than you think. Spot any Objective-C sorcery, and kill it for good. In the next article, I will show you how conditionals and dependency injection allows us to still use frameworks that are not available on all platforms.]]></summary></entry><entry><title type="html">Scripting and open-source adoption</title><link href="https://davidederosa.com/2025/04/scripting-and-open-source-adoption/" rel="alternate" type="text/html" title="Scripting and open-source adoption" /><published>2025-04-24T00:00:00+02:00</published><updated>2025-04-24T00:00:00+02:00</updated><id>https://davidederosa.com/2025/04/scripting-and-open-source-adoption</id><content type="html" xml:base="https://davidederosa.com/2025/04/scripting-and-open-source-adoption/"><![CDATA[<p>Recently, I stumbled upon an <a href="https://www.youtube.com/watch?v=p0Q3oDY9A5s">old video by ThePrimeagen</a> where he claimed he’d quit using Vim for good after its major update.</p>

<p>For those who don’t know, <a href="https://www.vim.org/">Vim</a> is a <em>ubiquitous</em> text editor, especially popular among avid terminal-oriented users. It is a legendary software, but it has a steep learning curve, to the point that “quitting Vim” <a href="https://stackoverflow.com/questions/11828270/how-do-i-exit-vim">has become a meme</a> for being notoriously unintuitive.</p>

<p><a href="https://twitch.tv/theprimeagen">ThePrimeagen</a> is a prominent Twitch streamer, and a staunch advocate of <a href="https://neovim.io/">Neovim</a>, a fork of the original Vim editor. In his video, he makes a solid point about the stubbornness of Vim maintainers to stick with a custom scripting language. On the other hand, Neovim, promotes the well-known <a href="https://www.lua.org/">Lua</a> language for its powerful plugin system. This alone determined his final choice to stick with Neovim, and as of 2025, I doubt he has changed his mind.</p>

<h3 id="the-delusion-behind-open-source">The delusion behind open-source</h3>

<p>This story is somewhat related to what I’m trying now that I work full-time on <a href="https://passepartoutvpn.app">Passepartout</a>. Passepartout is an open-source project in that its code is public, but there are almost no code contributions, just issues. There are good reasons behind this.</p>

<p>Many of those who improvise some sort of open-source software think that it must be interesting by default, just because it’s open and available for free. Rarely will they realize that <em>popular</em> free software is not popular <em>only for being free</em>, so they live in the delusion that the open-source model “doesn’t work”.</p>

<p>For example, pick any GNU tool (grep, sed, make, …) or even Linux. They became popular because they were <em>useful</em>. Being free and <em>understandable</em> software made them thrive through public contributions, but this was never the first step.</p>

<p>The interest in contributing to an open-source project is determined by multiple factors, in order of importance:</p>

<ol>
  <li>Goals</li>
  <li>Well-written documentation and directions</li>
  <li>Welcoming community</li>
  <li>Technical stack</li>
  <li>Stable software architecture</li>
</ol>

<p>Now, observe how any well-known free software meets 1-5 in that order.</p>

<h3 id="vim-and-the-self-conscious-tech">Vim and the self-conscious tech</h3>

<p>Given that both Vim and Neovim are amazing and well-documented products, their tech paths reconnect with the initial backstory.</p>

<p>Lua makes Neovim <em>infinitely</em> more attractive than Vim when it comes to adoption and open-source, and the choice of Vimscript over Lua may even determine the death of Vim in the long run. I don’t know the “drama” that resulted in the fork of Neovim, but I wouldn’t exclude that Vim took its relevance for granted just for being the OG of the two. In fact, I don’t think that Vim today can claim being cooler than Neovim other than for being the original one.</p>

<p>Even if a software is well-crafted, it’s evident that a Pascal application will only attract a handful of developers, whereas JavaScript would open up to the entire globe, and the same applies to Vimscript versus Lua. If your software is written for yourself and requires developers to learn a new technology to contribute, either it is the most remarkable piece of art in software history, or you might well end up yelling at your echo chamber.</p>

<h3 id="a-new-javascript-api-in-passepartout">A new JavaScript API in Passepartout</h3>

<p>The Vim story taught me that I needed to make my project more accessible to the potential contributors, otherwise it will never be more than a one-man team.</p>

<p>While I invest a lot in making the software architecture as modular as I can, I haven’t spent as much time in documenting <em>how</em> to start contributing to the codebase. I know myself how intimidating it is to submit a PR to someone else’s repository, so it’s crucial that we, the maintainers, provide a viable entry point to those willing to collaborate. A welcoming, non-judging community also reduces the friction of the first public contribution.</p>

<p>One part that I’ve always found potentially accessible was the Providers API, which is how Passepartout auto-compiles VPN configurations for a plethora of provider servers. Nevertheless, no one ever contributed a single provider, and no wonder: providers were generated in CI with a convoluted set of undocumented Ruby scripts. Who on Earth would want to touch that mess?</p>

<p>When I found out about <a href="https://developer.apple.com/documentation/javascriptcore">JavaScriptCore</a> to solve a different problem, I suddenly realized how scripting could be a lower barrier to enter the Passepartout codebase, as there are way more JavaScript than Swift developers out there.</p>

<p>With the help of AI, I rapidly converted the old Ruby legacy to a brand new <a href="https://github.com/passepartoutvpn/api-source">Node.js implementation</a> that most developers would find easy to understand, develop, and test without even installing the app. Then I started documenting <a href="https://github.com/passepartoutvpn/api-source?tab=readme-ov-file#new-providers">how to submit a provider</a> step by step. This doesn’t imply that people will start adding new providers today, but offering accessible tools and documentation is a <em>strict</em> requirement for that to happen.</p>

<h3 id="conclusions">Conclusions</h3>

<p>Open-source success isn’t about being free, it’s about being accessible. Tools like Neovim thrive because they choose approachable technologies like Lua, making contributions easier. Similarly, by adopting JavaScript for scripting, Passepartout lowers its barrier to entry and opens the door to wider community involvement. If you want contributors, you must meet them where they are.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="lua" /><category term="javascript" /><category term="vim" /><category term="neovim" /><category term="open-source" /><summary type="html"><![CDATA[Recently, I stumbled upon an old video by ThePrimeagen where he claimed he’d quit using Vim for good after its major update. For those who don’t know, Vim is a ubiquitous text editor, especially popular among avid terminal-oriented users. It is a legendary software, but it has a steep learning curve, to the point that “quitting Vim” has become a meme for being notoriously unintuitive. ThePrimeagen is a prominent Twitch streamer, and a staunch advocate of Neovim, a fork of the original Vim editor. In his video, he makes a solid point about the stubbornness of Vim maintainers to stick with a custom scripting language. On the other hand, Neovim, promotes the well-known Lua language for its powerful plugin system. This alone determined his final choice to stick with Neovim, and as of 2025, I doubt he has changed his mind. The delusion behind open-source This story is somewhat related to what I’m trying now that I work full-time on Passepartout. Passepartout is an open-source project in that its code is public, but there are almost no code contributions, just issues. There are good reasons behind this. Many of those who improvise some sort of open-source software think that it must be interesting by default, just because it’s open and available for free. Rarely will they realize that popular free software is not popular only for being free, so they live in the delusion that the open-source model “doesn’t work”. For example, pick any GNU tool (grep, sed, make, …) or even Linux. They became popular because they were useful. Being free and understandable software made them thrive through public contributions, but this was never the first step. The interest in contributing to an open-source project is determined by multiple factors, in order of importance: Goals Well-written documentation and directions Welcoming community Technical stack Stable software architecture Now, observe how any well-known free software meets 1-5 in that order. Vim and the self-conscious tech Given that both Vim and Neovim are amazing and well-documented products, their tech paths reconnect with the initial backstory. Lua makes Neovim infinitely more attractive than Vim when it comes to adoption and open-source, and the choice of Vimscript over Lua may even determine the death of Vim in the long run. I don’t know the “drama” that resulted in the fork of Neovim, but I wouldn’t exclude that Vim took its relevance for granted just for being the OG of the two. In fact, I don’t think that Vim today can claim being cooler than Neovim other than for being the original one. Even if a software is well-crafted, it’s evident that a Pascal application will only attract a handful of developers, whereas JavaScript would open up to the entire globe, and the same applies to Vimscript versus Lua. If your software is written for yourself and requires developers to learn a new technology to contribute, either it is the most remarkable piece of art in software history, or you might well end up yelling at your echo chamber. A new JavaScript API in Passepartout The Vim story taught me that I needed to make my project more accessible to the potential contributors, otherwise it will never be more than a one-man team. While I invest a lot in making the software architecture as modular as I can, I haven’t spent as much time in documenting how to start contributing to the codebase. I know myself how intimidating it is to submit a PR to someone else’s repository, so it’s crucial that we, the maintainers, provide a viable entry point to those willing to collaborate. A welcoming, non-judging community also reduces the friction of the first public contribution. One part that I’ve always found potentially accessible was the Providers API, which is how Passepartout auto-compiles VPN configurations for a plethora of provider servers. Nevertheless, no one ever contributed a single provider, and no wonder: providers were generated in CI with a convoluted set of undocumented Ruby scripts. Who on Earth would want to touch that mess? When I found out about JavaScriptCore to solve a different problem, I suddenly realized how scripting could be a lower barrier to enter the Passepartout codebase, as there are way more JavaScript than Swift developers out there. With the help of AI, I rapidly converted the old Ruby legacy to a brand new Node.js implementation that most developers would find easy to understand, develop, and test without even installing the app. Then I started documenting how to submit a provider step by step. This doesn’t imply that people will start adding new providers today, but offering accessible tools and documentation is a strict requirement for that to happen. Conclusions Open-source success isn’t about being free, it’s about being accessible. Tools like Neovim thrive because they choose approachable technologies like Lua, making contributions easier. Similarly, by adopting JavaScript for scripting, Passepartout lowers its barrier to entry and opens the door to wider community involvement. If you want contributors, you must meet them where they are.]]></summary></entry><entry><title type="html">Cross-platform Swift: Combine</title><link href="https://davidederosa.com/cross-platform-swift/combine/" rel="alternate" type="text/html" title="Cross-platform Swift: Combine" /><published>2025-04-23T00:00:00+02:00</published><updated>2025-04-23T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-combine</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/combine/"><![CDATA[<p>The very first goal of porting may sound simple: a successful build. Once you manage to just compile your package, the worst is definitely behind you.</p>

<p>Keep in mind that this is not a series about how to port Apple frameworks or SwiftUI to other platforms, it’s about the bare Swift language. I want to show you how Xcode may trick you into thinking that some patterns are a key part of Swift, whereas they should be avoided if you plan to leave the Apple ecosystem at some point.</p>

<p>Today, I’ll talk about a kind of infamous framework for Swift developers: <em>Combine</em>.</p>

<h2 id="combine-is-unofficially-obsolete">Combine is unofficially obsolete</h2>

<p>When the compiler suddenly stopped at some occurrence of <code class="language-plaintext highlighter-rouge">import Combine</code>, I was beaten. Combine has been a fundamental piece of reactive programming for the last 5+ years, and any recent Swift codebase uses Combine to some extent. The scary question was: to what extent was I using it?</p>

<p>Let me digress a moment. There is a big problem with Combine, and it’s not about the developers using it. Apple is well-known for disrupting its own frameworks regardless of any backward-compatibility, and Combine is one of those examples where Apple took a different turn without offering a full replacement. Initially, it seemed that SwiftUI was all about Combine, but the introduction of Concurrency made the poor framework an outcast. Unsurprisingly, <code class="language-plaintext highlighter-rouge">ObservableObject</code> and <code class="language-plaintext highlighter-rouge">@Published</code> are also unavailable outside Apple Swift, but if you’ve been a diligent programmer, you’ve probably learned that those constructs only make sense with SwiftUI.</p>

<p>The fact that Combine has never been integrated into the Swift language, reveals that Concurrency is how Swift (and Apple) wants you to perform asynchronous programming from now on. Does Swift natively offer a substitute for the long list of Combine operators? Hell, no, and that’s why people still use Combine.</p>

<p>Back to my question. Luckily, my use of Combine in Partout was quite basic, except for one <code class="language-plaintext highlighter-rouge">.combineLatest3()</code> that was worth half the effort.</p>

<h2 id="porting-to-asyncsequence">Porting to AsyncSequence</h2>

<p>If you remember, the purpose of Combine is manipulating a sequence of asynchronous values. Swift offers implementations of <a href="https://developer.apple.com/documentation/swift/asyncsequence"><code class="language-plaintext highlighter-rouge">AsyncSequence</code></a> like <a href="https://developer.apple.com/documentation/swift/asyncstream"><code class="language-plaintext highlighter-rouge">AsyncStream</code></a> and <a href="https://developer.apple.com/documentation/swift/asyncthrowingstream"><code class="language-plaintext highlighter-rouge">AsyncThrowingStream</code></a> to accomplish the same in a linear fashion, typical of the async/await model.</p>

<p>What in Combine was:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subscription</span> <span class="o">=</span> <span class="nf">somePublisherOfStrings</span><span class="p">()</span> <span class="c1">// AnyPublisher&lt;String, Never&gt;</span>
    <span class="o">.</span><span class="nf">removeDuplicates</span><span class="p">()</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"String: </span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>becomes this with <code class="language-plaintext highlighter-rouge">AsyncStream</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subscription</span> <span class="o">=</span> <span class="kt">Task</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span>
    <span class="k">var</span> <span class="nv">previous</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">for</span> <span class="k">await</span> <span class="n">string</span> <span class="k">in</span> <span class="nf">someStreamOfStrings</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// AsyncStream&lt;String&gt;</span>
        <span class="k">guard</span> <span class="n">string</span> <span class="o">!=</span> <span class="n">previous</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"String: </span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">string</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, a typical way to spawn Combine publishers is with <em>subjects</em> (<code class="language-plaintext highlighter-rouge">PassthroughSubject</code> and <code class="language-plaintext highlighter-rouge">CurrentValueSubject</code>), that are multicast emitters of values. Multiple programs can subscribe to a subject, listen to its sequence of values, and manipulate them before delivery with the rich offer of Combine operators. We lack such a counterpart in Swift, so I went to <a href="https://github.com/keeshux/subject-streams">roll out my own</a>.</p>

<p>My <a href="https://github.com/keeshux/subject-streams/blob/master/Sources/SubjectStreams/PassthroughStream.swift"><code class="language-plaintext highlighter-rouge">PassthroughStream</code></a> and <a href="https://github.com/keeshux/subject-streams/blob/master/Sources/SubjectStreams/CurrentValueStream.swift"><code class="language-plaintext highlighter-rouge">CurrentValueStream</code></a> implement a simple pub/sub pattern with <code class="language-plaintext highlighter-rouge">AsyncStream</code> and strict Swift 6.1 Concurrency. They have become the building blocks of all my asynchronous publishers in cross-platform Swift, and by keeping behavior and naming close to Combine (e.g. the <code class="language-plaintext highlighter-rouge">.send()</code> method), the refactoring was easier to manage.</p>

<p>Steps:</p>

<ul>
  <li>Replace Combine subjects with <a href="https://github.com/keeshux/subject-streams"><em>subject streams</em></a></li>
  <li>Return an <code class="language-plaintext highlighter-rouge">AsyncStream</code> from a subject with <code class="language-plaintext highlighter-rouge">.subscribe()</code></li>
  <li>Replace <code class="language-plaintext highlighter-rouge">AnyCancellable</code> with <code class="language-plaintext highlighter-rouge">Task</code> and <code class="language-plaintext highlighter-rouge">for [try] await</code> loops (<code class="language-plaintext highlighter-rouge">weak self</code> here)</li>
</ul>

<p>Before:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">RandomGenerator</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>

    <span class="k">var</span> <span class="nv">publisher</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">generator</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">generator</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="o">.</span><span class="nf">random</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="mi">1</span><span class="o">...</span><span class="mi">1000</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="k">let</span> <span class="nv">prng</span> <span class="o">=</span> <span class="kt">RandomGenerator</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">subscription</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">publisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">value</span> <span class="k">in</span>
    <span class="o">...</span>
<span class="p">}</span>

</code></pre></div></div>

<p>After:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">RandomGenerator</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">PassthroughStream</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">()</span>

    <span class="k">var</span> <span class="nv">publisher</span><span class="p">:</span> <span class="kt">AsyncStream</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">generator</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">generator</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="o">.</span><span class="nf">random</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="mi">1</span><span class="o">...</span><span class="mi">1000</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="k">let</span> <span class="nv">prng</span> <span class="o">=</span> <span class="kt">RandomGenerator</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">subscription</span> <span class="o">=</span> <span class="kt">Task</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span>
    <span class="k">for</span> <span class="k">await</span> <span class="n">value</span> <span class="k">in</span> <span class="n">prng</span><span class="o">.</span><span class="n">publisher</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="bottom-line">Bottom line</h2>

<p>Leaving Combine behind is a disruptive step towards both Swift 6 and cross-platform. Personally, I still don’t fully trust the behavior of <code class="language-plaintext highlighter-rouge">AsyncSequence</code>, but what are we left with? Apple is forcing developers towards Concurrency, and soon there will be no choice but to embrace it. And I’m glad, because it’s finally bringing consistency to the language.</p>

<p>We’re close to building the Partout core on both Windows and Linux. In the next article, I will cover some quirks I’m facing with the core libraries.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><summary type="html"><![CDATA[The very first goal of porting may sound simple: a successful build. Once you manage to just compile your package, the worst is definitely behind you. Keep in mind that this is not a series about how to port Apple frameworks or SwiftUI to other platforms, it’s about the bare Swift language. I want to show you how Xcode may trick you into thinking that some patterns are a key part of Swift, whereas they should be avoided if you plan to leave the Apple ecosystem at some point. Today, I’ll talk about a kind of infamous framework for Swift developers: Combine. Combine is unofficially obsolete When the compiler suddenly stopped at some occurrence of import Combine, I was beaten. Combine has been a fundamental piece of reactive programming for the last 5+ years, and any recent Swift codebase uses Combine to some extent. The scary question was: to what extent was I using it? Let me digress a moment. There is a big problem with Combine, and it’s not about the developers using it. Apple is well-known for disrupting its own frameworks regardless of any backward-compatibility, and Combine is one of those examples where Apple took a different turn without offering a full replacement. Initially, it seemed that SwiftUI was all about Combine, but the introduction of Concurrency made the poor framework an outcast. Unsurprisingly, ObservableObject and @Published are also unavailable outside Apple Swift, but if you’ve been a diligent programmer, you’ve probably learned that those constructs only make sense with SwiftUI. The fact that Combine has never been integrated into the Swift language, reveals that Concurrency is how Swift (and Apple) wants you to perform asynchronous programming from now on. Does Swift natively offer a substitute for the long list of Combine operators? Hell, no, and that’s why people still use Combine. Back to my question. Luckily, my use of Combine in Partout was quite basic, except for one .combineLatest3() that was worth half the effort. Porting to AsyncSequence If you remember, the purpose of Combine is manipulating a sequence of asynchronous values. Swift offers implementations of AsyncSequence like AsyncStream and AsyncThrowingStream to accomplish the same in a linear fashion, typical of the async/await model. What in Combine was: subscription = somePublisherOfStrings() // AnyPublisher&lt;String, Never&gt; .removeDuplicates() .sink { [weak self] in print("String: \($0)") } becomes this with AsyncStream: subscription = Task { [weak self] in var previous: String? for await string in someStreamOfStrings() { // AsyncStream&lt;String&gt; guard string != previous else { continue } print("String: \($0)") previous = string } } Now, a typical way to spawn Combine publishers is with subjects (PassthroughSubject and CurrentValueSubject), that are multicast emitters of values. Multiple programs can subscribe to a subject, listen to its sequence of values, and manipulate them before delivery with the rich offer of Combine operators. We lack such a counterpart in Swift, so I went to roll out my own. My PassthroughStream and CurrentValueStream implement a simple pub/sub pattern with AsyncStream and strict Swift 6.1 Concurrency. They have become the building blocks of all my asynchronous publishers in cross-platform Swift, and by keeping behavior and naming close to Combine (e.g. the .send() method), the refactoring was easier to manage. Steps: Replace Combine subjects with subject streams Return an AsyncStream from a subject with .subscribe() Replace AnyCancellable with Task and for [try] await loops (weak self here) Before: final class RandomGenerator { private let generator = PassthroughSubject&lt;Int, Never&gt;() var publisher: AnyPublisher&lt;Int, Never&gt; { generator.eraseToAnyPublisher() } func run() { generator.send(.random(in: 1...1000)) } } ... let prng = RandomGenerator() var subscription = prng.publisher.sink { [weak self] value in ... } After: final class RandomGenerator { private let generator = PassthroughStream&lt;Int&gt;() var publisher: AsyncStream&lt;Int&gt; { generator.subscribe() } func run() { generator.send(.random(in: 1...1000)) } } ... let prng = RandomGenerator() var subscription = Task { [weak self] in for await value in prng.publisher { ... } } Bottom line Leaving Combine behind is a disruptive step towards both Swift 6 and cross-platform. Personally, I still don’t fully trust the behavior of AsyncSequence, but what are we left with? Apple is forcing developers towards Concurrency, and soon there will be no choice but to embrace it. And I’m glad, because it’s finally bringing consistency to the language. We’re close to building the Partout core on both Windows and Linux. In the next article, I will cover some quirks I’m facing with the core libraries.]]></summary></entry><entry><title type="html">Cross-platform Swift: Introduction</title><link href="https://davidederosa.com/cross-platform-swift/" rel="alternate" type="text/html" title="Cross-platform Swift: Introduction" /><published>2025-04-13T00:00:00+02:00</published><updated>2025-04-13T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift-introduction</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/"><![CDATA[<p>As <a href="https://github.com/passepartoutvpn/partout">Partout</a>, my Swift framework for VPN and network configuration on Apple devices, has slowly gained shape, I set foot in an ambitious and novel, pioneering goal: <strong>making Partout a truly multiplatform Swift library</strong>. Also, a library that integrates with multiple programming languages where Swift is the coordinator, with the help of the C interoperability.</p>

<p>It’s challenging, but it’s fun, and it’s the way to port <a href="https://passepartoutvpn.app">Passepartout</a> beyond the Apple platforms. So, here, I will progressively share my discoveries and encourage other people to give Swift a chance as a portable language. The language itself is fantastic. Using it outside Xcode? Not as much, but I’ve observed the trends over the years, and overall, things are getting better.</p>

<p>This <a href="https://developer.apple.com/videos/play/wwdc2024/10197/">video from WWDC 2024</a> where the speaker uses Neovim + CMake made me reflect on the increasing efforts that Apple is making to push Swift into the outer world. Endorsing Neovim to develop Swift is an incredible marketing move to expand on Linux primarily, but I don’t mind it because both Neovim and Swift are amazing products.</p>

<p>Bear with me, this is a <em>very experimental</em> work in progress, that’s why I’d rather start with architectural concepts, and delve into technical details only after confirming that my approaches do well in practice.</p>

<h2 id="leaving-the-apple-toolchain">Leaving the Apple toolchain</h2>

<p>I picked Windows as the starting point of my journey. Windows is as far as one can go with Swift, so if my library works there, porting it to Android and Linux should be easier. In this post I’ll outline some fundamental principles to keep in mind before touching any code.</p>

<p><em>Downloading Swift with WinGet</em>
<img src="/s/posts/2025-04-13-01.png" alt="Downloading Swift with WinGet" /></p>

<h3 id="1-start-with-a-lean-core">1. Start with a lean core</h3>

<p>When I made Partout from the ashes of <a href="https://github.com/passepartoutvpn/tunnelkit">TunnelKit</a>, I put special care into making the library core as lean as possible. No dependencies, no OS implementations, pure Swift. This mantra paid off very well in the long run because you realize how basic the Swift runtime is when you leave the comfortable macOS environment: a stripped version of the Foundation and Dispatch frameworks, not even Combine, and little more. I promise, this will hit you hard the first time.</p>

<p>I was equally shocked, yet positively, when <code class="language-plaintext highlighter-rouge">async</code> methods worked out of the box. This is not about Swift, though, rather about Windows. The level of discomfort I feel when I use Windows puts me in a constant disbelief when things, eventually, work as intended. As in “this is Windows, nothing can work without Visual Studio”. Fun fact: Swift requires the Visual Studio Build Tools.</p>

<p><strong>Challenge #1: Only depend on Foundation.</strong></p>

<h3 id="2-objc-no-thanks">2. ObjC? No, thanks</h3>

<p>Another painful wake-up call: the Swift toolchain does not support ObjC targets in SwiftPM on non-Apple. There are three scenarios:</p>

<ol>
  <li>If you depend on 3rd party Swift packages based on ObjC code, move on to something else. Most of the time there will be better options.</li>
  <li>If you need to write low-level code with Swift, prefer some well-crafted C routines. You’ll thank yourself later.</li>
  <li>If you (like me) have legacy ObjC code –a good amount of my OpenVPN implementation is written in ObjC for performance reasons–, hear me out: it’s going to cause you trouble.</li>
</ol>

<p>As far as I can tell, there are no easy shortcuts to resolve point 3. Keep in mind that the first challenge still applies: pray that your ObjC codebase only depends on Foundation or libraries that <em>you</em> bundle –thus excluding Apple frameworks, or you’re basically screwed.</p>

<p>Assuming that this is the case, you should treat ObjC like any other “foreign” language, which is with an external build tool. Once you build the ObjC code as a static library (e.g. with a <code class="language-plaintext highlighter-rouge">Makefile</code>), you have the option to add it as a binary target to the SwiftPM manifest. The same way you would do with Rust or Go, to name some. Unfortunately, this degrades the otherwise neat automation of SwiftPM.</p>

<p>Currently, I’m exploring a solution to reuse my ObjC code as is with <a href="https://www.mingw-w64.org/">MinGW64</a> and <a href="https://www.gnustep.org/">GNUstep</a>, as you can see in the screenshot below (forgive my swearing after hours of frustrating attempts…). So far, so good, though I’m still concerned with how MSYS2/MinGW64 handles the binary architectures.</p>

<p><strong>Challenge #2: Prefer C over ObjC, if you can.</strong></p>

<p><em>Compiling ObjC with MinGW + GNUstep</em>
<img src="/s/posts/2025-04-13-02.png" alt="Compiling ObjC with MinGW + GNUstep" /></p>

<h3 id="3-implementations">3. Implementations</h3>

<p>I still want to use the keychain and Network Extension on Apple systems. A lean core will inevitably lead to taking Swift targets depending on them out of the core and be imported conditionally. These are the “leaves” of the library, the ones where we have the most freedom, even on the programming language.</p>

<p>When it comes to Partout, this is of the utmost importance because it involves how the VPN functionality is implemented on each operating system. While this is clear to me on Apple (Network Extension), for Windows, I’m looking into the <a href="https://github.com/microsoft/UwpVpnPluginSample">Universal Windows Platform (UWP)</a>. As proof of the freedom we have in this area, the VPN code for Partout on Windows will likely be C#.</p>

<p><strong>Challenge #3: Isolate implementation targets.</strong></p>

<h3 id="4-c-is-the-common-denominator">4. C is the common denominator</h3>

<p>Sad to say, but it doesn’t really matter how cool your Swift library is (replace with any other language). The well-thought classes, the scalable design, the smart patterns, the tricky use of OOP: forget about any of those by the time you expose the library to a different programming language. Nobody cares, really, because interoperability is done in C.</p>

<p>Have you wondered how to expose a Swift protocol with an associatedtype to a Python library, an object with a lifetime, or even just a String? Well, the answer is straightforward: you don’t do that. Instead, you expose C wrappers from Swift with <a href="https://forums.swift.org/t/formalizing-cdecl/40677">@_cdecl</a>, which despite the leading underscore seems to be widely accepted as a pseudostable feature. It goes without saying, you will be limited to the standard C types.</p>

<p>This will be a late stage of the refactoring, today I’m not worried. A solid approach to challenge #1 would definitely make this easier.</p>

<p><strong>Challenge #4: Make your public interface a C API.</strong></p>

<h2 id="bottom-line">Bottom line</h2>

<p>I’m still in the early stages of bringing Swift to Windows, Android, and Linux with Partout, but the path is starting to reveal itself. Keep your core lean and pure Swift, avoid Objective-C where you can, isolate OS-specific implementations, and remember that C is the common ground across platforms. It’s experimental, sometimes frustrating, but genuinely fun—and worth sharing as it unfolds. Expect more on this throughout 2025.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><summary type="html"><![CDATA[As Partout, my Swift framework for VPN and network configuration on Apple devices, has slowly gained shape, I set foot in an ambitious and novel, pioneering goal: making Partout a truly multiplatform Swift library. Also, a library that integrates with multiple programming languages where Swift is the coordinator, with the help of the C interoperability. It’s challenging, but it’s fun, and it’s the way to port Passepartout beyond the Apple platforms. So, here, I will progressively share my discoveries and encourage other people to give Swift a chance as a portable language. The language itself is fantastic. Using it outside Xcode? Not as much, but I’ve observed the trends over the years, and overall, things are getting better. This video from WWDC 2024 where the speaker uses Neovim + CMake made me reflect on the increasing efforts that Apple is making to push Swift into the outer world. Endorsing Neovim to develop Swift is an incredible marketing move to expand on Linux primarily, but I don’t mind it because both Neovim and Swift are amazing products. Bear with me, this is a very experimental work in progress, that’s why I’d rather start with architectural concepts, and delve into technical details only after confirming that my approaches do well in practice. Leaving the Apple toolchain I picked Windows as the starting point of my journey. Windows is as far as one can go with Swift, so if my library works there, porting it to Android and Linux should be easier. In this post I’ll outline some fundamental principles to keep in mind before touching any code. Downloading Swift with WinGet 1. Start with a lean core When I made Partout from the ashes of TunnelKit, I put special care into making the library core as lean as possible. No dependencies, no OS implementations, pure Swift. This mantra paid off very well in the long run because you realize how basic the Swift runtime is when you leave the comfortable macOS environment: a stripped version of the Foundation and Dispatch frameworks, not even Combine, and little more. I promise, this will hit you hard the first time. I was equally shocked, yet positively, when async methods worked out of the box. This is not about Swift, though, rather about Windows. The level of discomfort I feel when I use Windows puts me in a constant disbelief when things, eventually, work as intended. As in “this is Windows, nothing can work without Visual Studio”. Fun fact: Swift requires the Visual Studio Build Tools. Challenge #1: Only depend on Foundation. 2. ObjC? No, thanks Another painful wake-up call: the Swift toolchain does not support ObjC targets in SwiftPM on non-Apple. There are three scenarios: If you depend on 3rd party Swift packages based on ObjC code, move on to something else. Most of the time there will be better options. If you need to write low-level code with Swift, prefer some well-crafted C routines. You’ll thank yourself later. If you (like me) have legacy ObjC code –a good amount of my OpenVPN implementation is written in ObjC for performance reasons–, hear me out: it’s going to cause you trouble. As far as I can tell, there are no easy shortcuts to resolve point 3. Keep in mind that the first challenge still applies: pray that your ObjC codebase only depends on Foundation or libraries that you bundle –thus excluding Apple frameworks, or you’re basically screwed. Assuming that this is the case, you should treat ObjC like any other “foreign” language, which is with an external build tool. Once you build the ObjC code as a static library (e.g. with a Makefile), you have the option to add it as a binary target to the SwiftPM manifest. The same way you would do with Rust or Go, to name some. Unfortunately, this degrades the otherwise neat automation of SwiftPM. Currently, I’m exploring a solution to reuse my ObjC code as is with MinGW64 and GNUstep, as you can see in the screenshot below (forgive my swearing after hours of frustrating attempts…). So far, so good, though I’m still concerned with how MSYS2/MinGW64 handles the binary architectures. Challenge #2: Prefer C over ObjC, if you can. Compiling ObjC with MinGW + GNUstep 3. Implementations I still want to use the keychain and Network Extension on Apple systems. A lean core will inevitably lead to taking Swift targets depending on them out of the core and be imported conditionally. These are the “leaves” of the library, the ones where we have the most freedom, even on the programming language. When it comes to Partout, this is of the utmost importance because it involves how the VPN functionality is implemented on each operating system. While this is clear to me on Apple (Network Extension), for Windows, I’m looking into the Universal Windows Platform (UWP). As proof of the freedom we have in this area, the VPN code for Partout on Windows will likely be C#. Challenge #3: Isolate implementation targets. 4. C is the common denominator Sad to say, but it doesn’t really matter how cool your Swift library is (replace with any other language). The well-thought classes, the scalable design, the smart patterns, the tricky use of OOP: forget about any of those by the time you expose the library to a different programming language. Nobody cares, really, because interoperability is done in C. Have you wondered how to expose a Swift protocol with an associatedtype to a Python library, an object with a lifetime, or even just a String? Well, the answer is straightforward: you don’t do that. Instead, you expose C wrappers from Swift with @_cdecl, which despite the leading underscore seems to be widely accepted as a pseudostable feature. It goes without saying, you will be limited to the standard C types. This will be a late stage of the refactoring, today I’m not worried. A solid approach to challenge #1 would definitely make this easier. Challenge #4: Make your public interface a C API. Bottom line I’m still in the early stages of bringing Swift to Windows, Android, and Linux with Partout, but the path is starting to reveal itself. Keep your core lean and pure Swift, avoid Objective-C where you can, isolate OS-specific implementations, and remember that C is the common ground across platforms. It’s experimental, sometimes frustrating, but genuinely fun—and worth sharing as it unfolds. Expect more on this throughout 2025.]]></summary></entry><entry><title type="html">Who cares about performance?</title><link href="https://davidederosa.com/2025/03/who-cares-about-performance/" rel="alternate" type="text/html" title="Who cares about performance?" /><published>2025-03-25T00:00:00+01:00</published><updated>2025-03-25T00:00:00+01:00</updated><id>https://davidederosa.com/2025/03/who-cares-about-performance</id><content type="html" xml:base="https://davidederosa.com/2025/03/who-cares-about-performance/"><![CDATA[<p>While many people copy and paste unoriginal thoughts about AI and the so-called “vibe coding”, it seems that what used to make software valuable is constantly put aside. If you try to argue that tech <em>does</em> matter in a tech-oriented product, they will tell you that:</p>

<ul>
  <li>Business is more important than engineering</li>
  <li>Software is useless if it doesn’t make money</li>
  <li>Users only care about features</li>
  <li>Devices are powerful, performance doesn’t matter</li>
  <li>Internet is fast, a few more GBs won’t hurt</li>
</ul>

<p>And many more dumb takes. This is the typical mentality by which consultancy firms produce the most mediocre products you will ever find.</p>

<p>I don’t want to delve into this endless – and hopeless – topic. Instead, I want to tell you a little story of how easy it is to lose control of software <em>performance</em>, and how the understanding of programming fundamentals keeps us in touch with reality. This has never been more important with the fast-paced opportunities that LLMs offer today.</p>

<h3 id="can-you-afford-low-performance">Can you afford low performance?</h3>

<p>I’m far from being a low-level programmer, yet I know C and the fundamentals of how things happen below the code.</p>

<p><a href="https://passepartoutvpn.app">Passepartout</a> is a networking app mostly dealing with VPN connections. At least in the tunnel context, performance <em>does</em> matter. When it comes to OpenVPN in particular, it’s very hard to compete with a pure C codebase – the official library – when you also have to account for the overhead of the Swift runtime. Let’s not forget about the <a href="https://developer.apple.com/forums/thread/73148">strict memory limits</a> of Network Extension either. The time I spent on profiling to improve efficiency, resolve memory leaks, and reduce the crash rate, among other things, is pretty massive.</p>

<p>Two months ago, a user reported a regression in the OpenVPN negotiation where the handshake would never complete. I could implement a fix quickly, yet the handshake took 4x longer than with the obsolete TunnelKit. A whopping and unacceptable 20-25s vs 5s negotiation!</p>

<h3 id="the-domino-effect-of-bad-choices">The domino effect of bad choices</h3>

<p>I inspected the negotiation steps carefully for bottlenecks:</p>

<ul>
  <li>Loops</li>
  <li>Blocking code</li>
  <li>Slow I/O</li>
  <li>Disputed locks</li>
  <li>Wrong artificial delays</li>
  <li>Parsing</li>
  <li>…and whatnot!</li>
</ul>

<p>Now, if your life as a programmer only revolved around high-level languages like JavaScript, Python, or even Swift, you will have a hard time realizing the <em>time cost</em> – not the <em>O(n)</em> cost – of your code. Similar to how knowing <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> helps immensely when profiling a slow <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORM</a>, knowing C helps you spot poor performance in high-level programs, even if you never get to write C code.</p>

<p>It took me 1-2 days to realize that the culprit was ironically where I expected it the least. The performance hit was caused by <a href="https://github.com/passepartoutvpn/passepartout/pull/1095">the parser of the PUSH_REPLY</a> message, which is a short comma-separated string. To be fair, the parser is quite basic, so it wasn’t the parser either: the problem was about <strong>re-creating the <code class="language-plaintext highlighter-rouge">NSRegularExpression</code> objects every time a new PUSH_REPLY was parsed</strong>.</p>

<p>Of course, it doesn’t take a lot to create an <code class="language-plaintext highlighter-rouge">NSRegularExpression</code> but the user’s server sent dozens of PUSH_REPLY messages to the client, so the slow code was adding up very quickly. Run a 100ms vs 500ms code once and it will be okay, but run it 20 times and you easily get a 2 seconds vs 10 seconds delay. In the vast majority of servers, the PUSH_REPLY is a single message, which made the nasty issue unnoticeable to most.</p>

<p>By then, I realized how too much OOP makes us programmers forget that even creating objects may be expensive. Imagine what AI can do without a supervisor. When performance is crucial, we should remind ourselves that the convenient, good-looking solution might be the <em>worse</em> choice.</p>

<h3 id="what-vibe-coders-may-not-be-ready-for">What “vibe coders” may not be ready for</h3>

<p>Before anything, ask yourself what <em>your business</em> is about. If you work at Netflix, or in the game industry, you might observe the immediate effect of an inefficient vibe-coded algorithm. In the trivial CRUD apps that make up 99.9% of the consultancy workforce, instead, you may only realize that your code has low performance after a long chain of bad choices, if ever.</p>

<p>Performance, however, is just an example of what’s being overseen due to the increasingly fast pace at which people produce code.</p>

<p>This leads to a few observations:</p>

<ul>
  <li>If your software is “stupid”, low performance may only be hidden and therefore not seem a big deal.</li>
  <li>Engineers who underestimate the importance of performant solutions, probably never worked on challenging projects.</li>
  <li>If performance doesn’t matter to <em>you</em> today, it doesn’t mean it’s not important in general. Or, that it won’t be important when <em>your</em> business scales up.</li>
</ul>

<p>When that day comes, will you have the knowledge you need to face it?</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><summary type="html"><![CDATA[While many people copy and paste unoriginal thoughts about AI and the so-called “vibe coding”, it seems that what used to make software valuable is constantly put aside. If you try to argue that tech does matter in a tech-oriented product, they will tell you that: Business is more important than engineering Software is useless if it doesn’t make money Users only care about features Devices are powerful, performance doesn’t matter Internet is fast, a few more GBs won’t hurt And many more dumb takes. This is the typical mentality by which consultancy firms produce the most mediocre products you will ever find. I don’t want to delve into this endless – and hopeless – topic. Instead, I want to tell you a little story of how easy it is to lose control of software performance, and how the understanding of programming fundamentals keeps us in touch with reality. This has never been more important with the fast-paced opportunities that LLMs offer today. Can you afford low performance? I’m far from being a low-level programmer, yet I know C and the fundamentals of how things happen below the code. Passepartout is a networking app mostly dealing with VPN connections. At least in the tunnel context, performance does matter. When it comes to OpenVPN in particular, it’s very hard to compete with a pure C codebase – the official library – when you also have to account for the overhead of the Swift runtime. Let’s not forget about the strict memory limits of Network Extension either. The time I spent on profiling to improve efficiency, resolve memory leaks, and reduce the crash rate, among other things, is pretty massive. Two months ago, a user reported a regression in the OpenVPN negotiation where the handshake would never complete. I could implement a fix quickly, yet the handshake took 4x longer than with the obsolete TunnelKit. A whopping and unacceptable 20-25s vs 5s negotiation! The domino effect of bad choices I inspected the negotiation steps carefully for bottlenecks: Loops Blocking code Slow I/O Disputed locks Wrong artificial delays Parsing …and whatnot! Now, if your life as a programmer only revolved around high-level languages like JavaScript, Python, or even Swift, you will have a hard time realizing the time cost – not the O(n) cost – of your code. Similar to how knowing SQL helps immensely when profiling a slow ORM, knowing C helps you spot poor performance in high-level programs, even if you never get to write C code. It took me 1-2 days to realize that the culprit was ironically where I expected it the least. The performance hit was caused by the parser of the PUSH_REPLY message, which is a short comma-separated string. To be fair, the parser is quite basic, so it wasn’t the parser either: the problem was about re-creating the NSRegularExpression objects every time a new PUSH_REPLY was parsed. Of course, it doesn’t take a lot to create an NSRegularExpression but the user’s server sent dozens of PUSH_REPLY messages to the client, so the slow code was adding up very quickly. Run a 100ms vs 500ms code once and it will be okay, but run it 20 times and you easily get a 2 seconds vs 10 seconds delay. In the vast majority of servers, the PUSH_REPLY is a single message, which made the nasty issue unnoticeable to most. By then, I realized how too much OOP makes us programmers forget that even creating objects may be expensive. Imagine what AI can do without a supervisor. When performance is crucial, we should remind ourselves that the convenient, good-looking solution might be the worse choice. What “vibe coders” may not be ready for Before anything, ask yourself what your business is about. If you work at Netflix, or in the game industry, you might observe the immediate effect of an inefficient vibe-coded algorithm. In the trivial CRUD apps that make up 99.9% of the consultancy workforce, instead, you may only realize that your code has low performance after a long chain of bad choices, if ever. Performance, however, is just an example of what’s being overseen due to the increasingly fast pace at which people produce code. This leads to a few observations: If your software is “stupid”, low performance may only be hidden and therefore not seem a big deal. Engineers who underestimate the importance of performant solutions, probably never worked on challenging projects. If performance doesn’t matter to you today, it doesn’t mean it’s not important in general. Or, that it won’t be important when your business scales up. When that day comes, will you have the knowledge you need to face it?]]></summary></entry><entry><title type="html">Frontend development is easy</title><link href="https://davidederosa.com/2025/03/frontend-development-is-easy/" rel="alternate" type="text/html" title="Frontend development is easy" /><published>2025-03-19T00:00:00+01:00</published><updated>2025-03-19T00:00:00+01:00</updated><id>https://davidederosa.com/2025/03/frontend-development-is-easy</id><content type="html" xml:base="https://davidederosa.com/2025/03/frontend-development-is-easy/"><![CDATA[<p>If you are a developer, you have heard this statement at least once. While I believe that any comparison is pointless because <em>everything</em> is about programming, I’d like to add some complexities often neglected in frontend development, within the context of client/server software.</p>

<h3 id="take-it-seriously">Take it seriously</h3>

<p>Frontend is not a toy. What I find frequent in frontend developers is the <em>recklessness</em> of their choices. Backend developers tend to be more conservative because they are the ones receiving that phone call at night when a service is down, but this doesn’t mean that a frontend bug couldn’t have terrible consequences.</p>

<p>Some people claim that backend is harder than frontend because of the “more serious” problems it has to solve:</p>

<ul>
  <li>Performance</li>
  <li>Scalability</li>
  <li>Robustness</li>
  <li>Concurrency</li>
</ul>

<p>For some reason, those qualities are considered less of a priority for a well-written client, but they are equally important and sometimes <em>more</em> important. Users may spot slow, sluggish, power-hungry, buggy apps from a distance.</p>

<p>It’s also true that if you skip native backend software like web servers or databases, which are a <em>big deal</em>, most developers out there are doing simple web services. Let’s be honest: nowadays, most of the above difficulties are not dealt with at the programming level, they are delegated to long-established SaaS platforms. This is great, but only because backend developers are –in my experience– generally more aware of how things happen under the hood.</p>

<p>Sadly, frontend frameworks lead developers in the opposite direction: they make you forget the consequences of bad programming practices. They deviate from the importance of appropriate data structures and algorithms. They convince you that modern machines can endure any load. They overcomplicate code with tons of boilerplate. They waste your time moving your focus on things that nobody cares about e.g. “is that a view or a view model?”. They make you lose the foundations of programming.</p>

<p>The result is a far west full of cowboys writing inefficient, dangerous code, but this is not a problem of the frontend itself.</p>

<h3 id="never-rely-on-a-backend">Never rely on a backend</h3>

<p>Not all apps are web-oriented, and <a href="https://passepartoutvpn.app">Passepartout</a> is an example of frontend development without a backend. Or, better said, frontend development with an uncontrolled backend.</p>

<p>What does this imply? You take <em>direct responsibility</em> for your software. In a world where most apps interact with external APIs, it’s appalling how often frontend developers operate in the best-case scenario where everything works as expected.</p>

<p>I wonder how many write code that, to name a few:</p>

<ul>
  <li>Expects malformed responses</li>
  <li>Expects no responses</li>
  <li>Handles timeouts</li>
  <li>Works fully offline</li>
  <li>Works headless (without views)</li>
  <li>Migrates persistent data without data loss</li>
</ul>

<p>This is your responsibility, not the external backend’s, and you do that by giving your frontend <em>a local backend</em> with business logic to rely on. At that point, the presence of an external backend will be of marginal importance.</p>

<h3 id="domain-before-ui">Domain before UI</h3>

<p>Business logic is another concept that, historically, the backend is more used to than the frontend. I believe that backend developers don’t see the immediate effect of their work until late, whereas
it takes a few minutes to create a meaningful UI. The instant gratification that comes from “it works!” may indefinitely delay the key decisions to take early in software development.</p>

<p>Presentation is the highest layer in software design, yet in frontend development, the importance of UI is constantly glorified. No surprise, non-tech people and the industry in general judge software from the UI, but frontend developers should prioritize the <em>domain</em> like any other non-UI developer does.</p>

<p>Any software should make sense regardless of having a UI, or a remote API, and frontend makes no exception: UI is no more than the visual representation of a domain. I believe that this simple rule also <em>dignifies</em> frontend apps for making them way more meaningful than “a couple of screens”.</p>

<h3 id="troubleshooting">Troubleshooting</h3>

<p>How much time do you waste interpreting users’ feedback for the lack of better options? What if you are in a real hurry to solve a frontend problem in production? Clients live in the most unpredictable environments, yet the troubleshooting of their errors is often deferred to backend monitoring.</p>

<p>Logging, proper error handling, profiling, and tracking tools are a superpower, but as long as the backend takes care of that, the frontend couldn’t care less. Drop the backend, and troubleshooting becomes a nightmare. Along the lines of “never rely on a backend”, do your homework and invest decent time in logging at least. Make it a requirement, even more than tests. It’s tedious, it’s time-consuming, but it truly pays off when SHTF.</p>

<p>Logging is a fundamental trait of software robustness, and it takes a lot of practice to describe what code does through human-readable text in a way that will help your future self later. No software is exempt from the need for logging.</p>

<h3 id="in-conclusion">In conclusion</h3>

<p>Frontend is the face of our product, but UI is only a small part of it. Over the years, the overuse of client-side JavaScript frameworks has made frontend software less of an example of good software design. At the end of the day, though, all design principles still apply, and frontend development deserves the same care and rigor as any other layer of software development.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><summary type="html"><![CDATA[If you are a developer, you have heard this statement at least once. While I believe that any comparison is pointless because everything is about programming, I’d like to add some complexities often neglected in frontend development, within the context of client/server software. Take it seriously Frontend is not a toy. What I find frequent in frontend developers is the recklessness of their choices. Backend developers tend to be more conservative because they are the ones receiving that phone call at night when a service is down, but this doesn’t mean that a frontend bug couldn’t have terrible consequences. Some people claim that backend is harder than frontend because of the “more serious” problems it has to solve: Performance Scalability Robustness Concurrency For some reason, those qualities are considered less of a priority for a well-written client, but they are equally important and sometimes more important. Users may spot slow, sluggish, power-hungry, buggy apps from a distance. It’s also true that if you skip native backend software like web servers or databases, which are a big deal, most developers out there are doing simple web services. Let’s be honest: nowadays, most of the above difficulties are not dealt with at the programming level, they are delegated to long-established SaaS platforms. This is great, but only because backend developers are –in my experience– generally more aware of how things happen under the hood. Sadly, frontend frameworks lead developers in the opposite direction: they make you forget the consequences of bad programming practices. They deviate from the importance of appropriate data structures and algorithms. They convince you that modern machines can endure any load. They overcomplicate code with tons of boilerplate. They waste your time moving your focus on things that nobody cares about e.g. “is that a view or a view model?”. They make you lose the foundations of programming. The result is a far west full of cowboys writing inefficient, dangerous code, but this is not a problem of the frontend itself. Never rely on a backend Not all apps are web-oriented, and Passepartout is an example of frontend development without a backend. Or, better said, frontend development with an uncontrolled backend. What does this imply? You take direct responsibility for your software. In a world where most apps interact with external APIs, it’s appalling how often frontend developers operate in the best-case scenario where everything works as expected. I wonder how many write code that, to name a few: Expects malformed responses Expects no responses Handles timeouts Works fully offline Works headless (without views) Migrates persistent data without data loss This is your responsibility, not the external backend’s, and you do that by giving your frontend a local backend with business logic to rely on. At that point, the presence of an external backend will be of marginal importance. Domain before UI Business logic is another concept that, historically, the backend is more used to than the frontend. I believe that backend developers don’t see the immediate effect of their work until late, whereas it takes a few minutes to create a meaningful UI. The instant gratification that comes from “it works!” may indefinitely delay the key decisions to take early in software development. Presentation is the highest layer in software design, yet in frontend development, the importance of UI is constantly glorified. No surprise, non-tech people and the industry in general judge software from the UI, but frontend developers should prioritize the domain like any other non-UI developer does. Any software should make sense regardless of having a UI, or a remote API, and frontend makes no exception: UI is no more than the visual representation of a domain. I believe that this simple rule also dignifies frontend apps for making them way more meaningful than “a couple of screens”. Troubleshooting How much time do you waste interpreting users’ feedback for the lack of better options? What if you are in a real hurry to solve a frontend problem in production? Clients live in the most unpredictable environments, yet the troubleshooting of their errors is often deferred to backend monitoring. Logging, proper error handling, profiling, and tracking tools are a superpower, but as long as the backend takes care of that, the frontend couldn’t care less. Drop the backend, and troubleshooting becomes a nightmare. Along the lines of “never rely on a backend”, do your homework and invest decent time in logging at least. Make it a requirement, even more than tests. It’s tedious, it’s time-consuming, but it truly pays off when SHTF. Logging is a fundamental trait of software robustness, and it takes a lot of practice to describe what code does through human-readable text in a way that will help your future self later. No software is exempt from the need for logging. In conclusion Frontend is the face of our product, but UI is only a small part of it. Over the years, the overuse of client-side JavaScript frameworks has made frontend software less of an example of good software design. At the end of the day, though, all design principles still apply, and frontend development deserves the same care and rigor as any other layer of software development.]]></summary></entry></feed>