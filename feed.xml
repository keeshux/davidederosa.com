<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://davidederosa.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://davidederosa.com/" rel="alternate" type="text/html" /><updated>2025-11-04T22:29:10+01:00</updated><id>https://davidederosa.com/feed.xml</id><title type="html">Davide De Rosa</title><subtitle>I make software. I look around me.</subtitle><author><name>Davide De Rosa</name></author><entry><title type="html">Cross-platform Swift: Build system (pt. 2)</title><link href="https://davidederosa.com/cross-platform-swift/build-system-part-two/" rel="alternate" type="text/html" title="Cross-platform Swift: Build system (pt. 2)" /><published>2025-11-04T00:00:00+01:00</published><updated>2025-11-04T00:00:00+01:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-build-system-part-two</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/build-system-part-two/"><![CDATA[<h2 id="our-goals">Our goals</h2>

<p>Before heading back to the <a href="https://github.com/partout-io/partout">Partout</a> code, let’s focus on our ultimate goals:</p>

<ol>
  <li>Build as Swift module on Apple platforms</li>
  <li>Build as dynamic library on other platforms (.so on Linux/Android, .dll on Windows)</li>
</ol>

<p>Adding that:</p>

<ul>
  <li>Step 1 is natural with SwiftPM, except for how to manage dependencies</li>
  <li>Step 2 involves OpenSSL (C), WireGuard (Go), and Wintun (Windows DLL) at the time of writing, plus the proper Swift runtime for the OS</li>
</ul>

<h2 id="step-1-building-with-swiftpm">Step 1: Building with SwiftPM</h2>

<p>We know that SwiftPM can handle Swift, C, C++, and ObjC (Apple only) sources with the help of module maps. How do we include dependencies that don’t use neither of these languages, or depend on a custom build system? We bundle them as <em>binary libraries</em>.</p>

<p>We need to take a short break and spot a major annoyance of this: contrary to source files, binary libraries are tied to a CPU architecture. That’s why <a href="https://developer.apple.com/documentation/xcode/distributing-binary-frameworks-as-swift-packages">XCFramework</a> was introduced, because it’s the best way to bundle binary libraries for multiple architectures. With a XCFramework, SwiftPM will pick the right binaries for the target architecture. This is exactly how I integrated OpenSSL and WireGuard into Partout, with the <a href="https://github.com/partout-io/openssl-apple">openssl-apple</a> and <a href="https://github.com/partout-io/wg-go-apple">wg-go-apple</a> repositories respectively.</p>

<p>One may argue that OpenSSL, for example, is written in C and SwiftPM supports C, but a build system may go miles further than a programming language. Building OpenSSL is a <em>very</em> complex task, and distributing prebuilt binaries is a standard way to decouple from such complexity. In exchange, we accept the complexity of handling multiple architectures with an XCFramework.</p>

<p>The problem with XCFrameworks, though, is that they do not work on non-Apple platforms. <strong>Artifact bundles</strong> will solve this limitation, unless Swift 6.2 has already introduced them (I remember this was half-done in July 2025).</p>

<h2 id="step-2-building-with-cmake">Step 2: Building with CMake</h2>

<p>Needless to say, SwiftPM is not mature enough on non-Apple. In order to have consistent builds of Swift code with binary dependencies, we’ll have resort to one of the least loved build tools around: <a href="https://cmake.org/">CMake</a>.</p>

<p>You know the say “love and hate”. Well, the thought of CMake generally leans towards “hate and hate”, because I haven’t heard a single developer that enjoys using it. In all fairness, the low popularity of CMake might stem from being the typical build system of C++ projects. I mean, there could be a bias, but we don’t care here, because CMake is somewhat the <em>only</em> way to accomplish what we need.</p>

<h3 id="why-cmake">Why CMake?</h3>

<p>CMake is not a replacement for Make, it’s rather a “generator of makefiles”, with a makefile being not necessarily the <code class="language-plaintext highlighter-rouge">Makefile</code> file, but the configuration file of a <em>build system</em>. The main feature of CMake is the ability of coordinating multiple projects written in different languages and/or built with different build systems. Since we are assembling a Frankenstein project made of Swift, C (OpenSSL), Go (WireGuard), and other prebuilt binary libraries (Wintun), CMake comes to our rescue.</p>

<p>For the record, CMake supports Swift code only through the <a href="https://ninja-build.org/"><code class="language-plaintext highlighter-rouge">ninja</code></a> generator.</p>

<h3 id="the-layout-of-our-superproject">The layout of our <em>superproject</em></h3>

<p>The first, comprehensive approach is to build our Swift library entirely with CMake. This is the most solid approach.</p>

<p>Partout is built in four steps:</p>

<ol>
  <li>The vendors are built as binary libraries. OpenSSL produces <code class="language-plaintext highlighter-rouge">libcrypto</code> and <code class="language-plaintext highlighter-rouge">libssl</code>, WireGuard produces <code class="language-plaintext highlighter-rouge">libwg-go</code>.</li>
  <li>The C/C++ code of our package is compiled as a monolith. Manual module maps must be exposed in the headers search paths for Swift interop with C/C++ code (SwiftPM does this automatically).</li>
  <li>The Swift code of our package is compiled altogether, thus losing any notion of SwiftPM sub-targets. C modules are available to Swift through step 2.</li>
  <li>All the outputs are linked together into the final dynamic library.</li>
</ol>

<p>Without delving into the very details of this complex task, we want to use a single CMake <em>superproject</em> to build our Swift project, Partout, plus all its dependencies. The superproject will treat both our Swift/C code and the vendors as opaque dependencies, i.e. <em>subprojects</em>. This way, CMake can ignore the internals of how any dependency is built.</p>

<p>Assume that each vendored third party comes with its own build system, and we orchestrate them all in a root <a href="https://github.com/partout-io/partout/blob/master/CMakeLists.txt"><code class="language-plaintext highlighter-rouge">CMakeLists.txt</code></a>. The root configuration includes one CMake file (*.cmake) for each vendor, as you can see in the <a href="https://github.com/partout-io/partout/tree/master/vendors"><code class="language-plaintext highlighter-rouge">vendors</code></a> directory of Partout. The .cmake files instruct the root configuration how to build each library as a subproject, and where to find the outputs, typically in the form of static or dynamic libraries.</p>

<p>Our package is also treated <a href="https://github.com/partout-io/partout/blob/master/Sources/CMakeLists.txt">as a subproject</a>, only as a monolith. By monolith, I mean that we give up on the granularity of SwiftPM targets and compile the Swift sources altogether. By doing this, the internal target imports will have to omitted, and we do that with the <code class="language-plaintext highlighter-rouge">PARTOUT_MONOLITH</code> symbol <a href="https://github.com/partout-io/partout/blob/9deda7b34107567ff4b76f53947ca718fe94956e/Sources/partout.cmake#L8">in the CMake project</a> and <a href="https://github.com/partout-io/partout/blob/9deda7b34107567ff4b76f53947ca718fe94956e/Sources/PartoutOS/Apple/AppleJavaScriptEngine.swift#L6">in the Swift code</a>.</p>

<p>You find the entry point of this long process in <a href="https://github.com/partout-io/partout/blob/master/scripts/build.sh"><code class="language-plaintext highlighter-rouge">scripts/build.sh</code></a>.</p>

<h3 id="hybrid-swiftpmcmake">Hybrid SwiftPM/CMake</h3>

<p>The full CMake approach works on all platforms except one: Android.</p>

<p>Why is that? Because, unless you want to rebuild the entire Swift toolchain for Android, the common way to target the Android platform is <a href="https://github.com/finagolfin/swift-android-sdk">through a Swift SDK</a>, and Swift SDKs only work with SwiftPM. On the other hand, building Swift for Android with CMake is still flaky and painful, so I’ll describe what we’re left with.</p>

<p>I chose to go with a hybrid build system where:</p>

<ul>
  <li>The Partout code (Swift/C) is built with SwiftPM, targeting the Swift Android SDK and the Android NDK.</li>
  <li>The vendored libraries are still built with CMake, this time for Android (<code class="language-plaintext highlighter-rouge">PP_BUILD_FOR_ANDROID</code> in CMake).</li>
  <li>SwiftPM depends on the CMake-built binaries via <code class="language-plaintext highlighter-rouge">.unsafeFlags</code> and generates a <code class="language-plaintext highlighter-rouge">.dynamic</code> library (<code class="language-plaintext highlighter-rouge">libpartout.so</code>).</li>
</ul>

<p>The way I accomplish this is with a <a href="https://github.com/partout-io/partout/blob/master/Package.swift">highly flexible Package.swift</a>. A dynamic manifest helps a lot when you need to overcome the occasional limitations of SwiftPM, and the <code class="language-plaintext highlighter-rouge">Package.swift</code> of Partout handles, among other things, OS conditionals and environment variables as the build input.</p>

<p>For example:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PP_BUILD_OS</code> works around the limitation of <code class="language-plaintext highlighter-rouge">#if os(Android)</code>, because the condition fails unless a full Android toolchain is used.</li>
  <li><code class="language-plaintext highlighter-rouge">PP_BUILD_CMAKE_OUTPUT</code> tells the SwiftPM build where to find the arch-specific outputs of CMake for use with <code class="language-plaintext highlighter-rouge">.unsafeFlags</code> (the well-known <code class="language-plaintext highlighter-rouge">-I</code>, <code class="language-plaintext highlighter-rouge">-L</code>, and <code class="language-plaintext highlighter-rouge">-l</code> flags of the compiler/linker).</li>
</ul>

<p>You can learn more about the whole process in <a href="https://github.com/partout-io/partout/blob/master/scripts/build-android.sh"><code class="language-plaintext highlighter-rouge">scripts/build-android.sh</code></a>.</p>

<h3 id="distribution">Distribution</h3>

<p>Will your Swift project work with <code class="language-plaintext highlighter-rouge">libpartout.so|.dylib|.dll</code> alone? Of course not. One reason is obvious, and it’s because you need to bundle the OpenSSL/WireGuard binaries too. The other reason is that your end-user will lack the <strong>Swift runtime</strong>, and this is still kind of a big deal.</p>

<p>As I mentioned in earlier posts, the Swift runtime is <em>big</em>, or <em>huge</em> if you use Foundation like nearly every Swift programmer does. It’s not even the worst part, as the one I dislike the most is that distributing the Swift runtime is a heavily manual process, and even the standard lib is made of dozens of files. Use <code class="language-plaintext highlighter-rouge">otool</code> (macOS) or <code class="language-plaintext highlighter-rouge">ldd</code> (Linux) on your output to learn what libraries you need, and beware that your app will crash on launch if it lacks any of them. In my experience, bundling <em>more</em> dependencies than necessary may also lead to runtime crashes.</p>

<p>The <code class="language-plaintext highlighter-rouge">-static-swift-stdlib</code> flag exists to embed the runtime and mitigate the issue, but it seems <a href="https://github.com/swiftlang/swift-package-manager/issues/8198">it doesn’t work properly for dynamic libraries</a>. It doesn’t help with Foundation either because it’s not part of the standard Swift library.</p>

<p>Long story short, <code class="language-plaintext highlighter-rouge">libpartout.so</code> must be distributed side by side with the CMake binaries and the whole Swift runtime for the target architecture. You should find the runtime libraries for your current architecture at:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$SWIFT_HOME/toolchains/&lt;swift_version&gt;/usr/lib/swift/&lt;platform_name&gt;
</code></pre></div></div>

<p>With an additional dependency on <a href="https://github.com/swiftlang/swift/blob/main/docs/Android.md#3-deploying-the-build-products-to-the-device"><code class="language-plaintext highlighter-rouge">libc++_shared.so</code> for Android</a>.</p>

<p>Anyway, this Linux output should explain better what I’m talking about:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldd src/passepartout/submodules/partout/.build/debug/libpartout.so 
	linux-vdso.so.1 (0x0000ec74cd2dc000)
	libswiftSwiftOnoneSupport.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswiftSwiftOnoneSupport.so (0x0000ec74ccc40000)
	libswiftCore.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswiftCore.so (0x0000ec74cc5a0000)
	libswift_Concurrency.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswift_Concurrency.so (0x0000ec74cc4f0000)
	libswift_StringProcessing.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswift_StringProcessing.so (0x0000ec74cc430000)
	libswift_RegexParser.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswift_RegexParser.so (0x0000ec74cc310000)
	libBlocksRuntime.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libBlocksRuntime.so (0x0000ec74cc2e0000)
	libdispatch.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libdispatch.so (0x0000ec74cc260000)
	libswiftDispatch.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswiftDispatch.so (0x0000ec74cc210000)
	libssl.so.3 =&gt; /lib/aarch64-linux-gnu/libssl.so.3 (0x0000ec74cc0f0000)
	libcrypto.so.3 =&gt; /lib/aarch64-linux-gnu/libcrypto.so.3 (0x0000ec74cbb60000)
	libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ec74cb990000)
	/lib/ld-linux-aarch64.so.1 (0x0000ec74cd2a0000)
	libstdc++.so.6 =&gt; /lib/aarch64-linux-gnu/libstdc++.so.6 (0x0000ec74cb6f0000)
	libm.so.6 =&gt; /lib/aarch64-linux-gnu/libm.so.6 (0x0000ec74cb630000)
	libgcc_s.so.1 =&gt; /lib/aarch64-linux-gnu/libgcc_s.so.1 (0x0000ec74cb5f0000)
	libswiftGlibc.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswiftGlibc.so (0x0000ec74cb5c0000)
	libz.so.1 =&gt; /lib/aarch64-linux-gnu/libz.so.1 (0x0000ec74cb580000)
	libzstd.so.1 =&gt; /lib/aarch64-linux-gnu/libzstd.so.1 (0x0000ec74cb4c0000)
</code></pre></div></div>

<h2 id="bottom-line">Bottom line</h2>

<p>I assumed the readers to be familiar with build systems and CMake in particular, as the subject is vast and goes way beyond the scope of my article. I rather wanted to describe the design that worked for me to build a <em>polyglot</em> Swift library not only for non-Apple platforms, but also with multi-language, real-world dependencies.</p>

<p>This is the real novelty, the one I’m so excited about, and the one that you would have a very hard time finding examples about. I’m bringing up proof that all this stuff <em>works</em> in Swift as Partout, the subject of this series, is not a toy project for the sake of a tutorial, but <strong>software in use by hundreds of thousands of users</strong> every day for streaming, privacy, remote work, and VPNs in general. Think about it for the bright future of the Swift language.</p>

<p>In the next article, we’ll go through the integration of Partout in both Swift and non-Swift applications, with my <a href="https://passepartoutvpn.app">Passepartout</a> app being the living example of it.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><category term="make" /><category term="cmake" /><summary type="html"><![CDATA[Our goals Before heading back to the Partout code, let’s focus on our ultimate goals: Build as Swift module on Apple platforms Build as dynamic library on other platforms (.so on Linux/Android, .dll on Windows) Adding that: Step 1 is natural with SwiftPM, except for how to manage dependencies Step 2 involves OpenSSL (C), WireGuard (Go), and Wintun (Windows DLL) at the time of writing, plus the proper Swift runtime for the OS Step 1: Building with SwiftPM We know that SwiftPM can handle Swift, C, C++, and ObjC (Apple only) sources with the help of module maps. How do we include dependencies that don’t use neither of these languages, or depend on a custom build system? We bundle them as binary libraries. We need to take a short break and spot a major annoyance of this: contrary to source files, binary libraries are tied to a CPU architecture. That’s why XCFramework was introduced, because it’s the best way to bundle binary libraries for multiple architectures. With a XCFramework, SwiftPM will pick the right binaries for the target architecture. This is exactly how I integrated OpenSSL and WireGuard into Partout, with the openssl-apple and wg-go-apple repositories respectively. One may argue that OpenSSL, for example, is written in C and SwiftPM supports C, but a build system may go miles further than a programming language. Building OpenSSL is a very complex task, and distributing prebuilt binaries is a standard way to decouple from such complexity. In exchange, we accept the complexity of handling multiple architectures with an XCFramework. The problem with XCFrameworks, though, is that they do not work on non-Apple platforms. Artifact bundles will solve this limitation, unless Swift 6.2 has already introduced them (I remember this was half-done in July 2025). Step 2: Building with CMake Needless to say, SwiftPM is not mature enough on non-Apple. In order to have consistent builds of Swift code with binary dependencies, we’ll have resort to one of the least loved build tools around: CMake. You know the say “love and hate”. Well, the thought of CMake generally leans towards “hate and hate”, because I haven’t heard a single developer that enjoys using it. In all fairness, the low popularity of CMake might stem from being the typical build system of C++ projects. I mean, there could be a bias, but we don’t care here, because CMake is somewhat the only way to accomplish what we need. Why CMake? CMake is not a replacement for Make, it’s rather a “generator of makefiles”, with a makefile being not necessarily the Makefile file, but the configuration file of a build system. The main feature of CMake is the ability of coordinating multiple projects written in different languages and/or built with different build systems. Since we are assembling a Frankenstein project made of Swift, C (OpenSSL), Go (WireGuard), and other prebuilt binary libraries (Wintun), CMake comes to our rescue. For the record, CMake supports Swift code only through the ninja generator. The layout of our superproject The first, comprehensive approach is to build our Swift library entirely with CMake. This is the most solid approach. Partout is built in four steps: The vendors are built as binary libraries. OpenSSL produces libcrypto and libssl, WireGuard produces libwg-go. The C/C++ code of our package is compiled as a monolith. Manual module maps must be exposed in the headers search paths for Swift interop with C/C++ code (SwiftPM does this automatically). The Swift code of our package is compiled altogether, thus losing any notion of SwiftPM sub-targets. C modules are available to Swift through step 2. All the outputs are linked together into the final dynamic library. Without delving into the very details of this complex task, we want to use a single CMake superproject to build our Swift project, Partout, plus all its dependencies. The superproject will treat both our Swift/C code and the vendors as opaque dependencies, i.e. subprojects. This way, CMake can ignore the internals of how any dependency is built. Assume that each vendored third party comes with its own build system, and we orchestrate them all in a root CMakeLists.txt. The root configuration includes one CMake file (*.cmake) for each vendor, as you can see in the vendors directory of Partout. The .cmake files instruct the root configuration how to build each library as a subproject, and where to find the outputs, typically in the form of static or dynamic libraries. Our package is also treated as a subproject, only as a monolith. By monolith, I mean that we give up on the granularity of SwiftPM targets and compile the Swift sources altogether. By doing this, the internal target imports will have to omitted, and we do that with the PARTOUT_MONOLITH symbol in the CMake project and in the Swift code. You find the entry point of this long process in scripts/build.sh. Hybrid SwiftPM/CMake The full CMake approach works on all platforms except one: Android. Why is that? Because, unless you want to rebuild the entire Swift toolchain for Android, the common way to target the Android platform is through a Swift SDK, and Swift SDKs only work with SwiftPM. On the other hand, building Swift for Android with CMake is still flaky and painful, so I’ll describe what we’re left with. I chose to go with a hybrid build system where: The Partout code (Swift/C) is built with SwiftPM, targeting the Swift Android SDK and the Android NDK. The vendored libraries are still built with CMake, this time for Android (PP_BUILD_FOR_ANDROID in CMake). SwiftPM depends on the CMake-built binaries via .unsafeFlags and generates a .dynamic library (libpartout.so). The way I accomplish this is with a highly flexible Package.swift. A dynamic manifest helps a lot when you need to overcome the occasional limitations of SwiftPM, and the Package.swift of Partout handles, among other things, OS conditionals and environment variables as the build input. For example: PP_BUILD_OS works around the limitation of #if os(Android), because the condition fails unless a full Android toolchain is used. PP_BUILD_CMAKE_OUTPUT tells the SwiftPM build where to find the arch-specific outputs of CMake for use with .unsafeFlags (the well-known -I, -L, and -l flags of the compiler/linker). You can learn more about the whole process in scripts/build-android.sh. Distribution Will your Swift project work with libpartout.so|.dylib|.dll alone? Of course not. One reason is obvious, and it’s because you need to bundle the OpenSSL/WireGuard binaries too. The other reason is that your end-user will lack the Swift runtime, and this is still kind of a big deal. As I mentioned in earlier posts, the Swift runtime is big, or huge if you use Foundation like nearly every Swift programmer does. It’s not even the worst part, as the one I dislike the most is that distributing the Swift runtime is a heavily manual process, and even the standard lib is made of dozens of files. Use otool (macOS) or ldd (Linux) on your output to learn what libraries you need, and beware that your app will crash on launch if it lacks any of them. In my experience, bundling more dependencies than necessary may also lead to runtime crashes. The -static-swift-stdlib flag exists to embed the runtime and mitigate the issue, but it seems it doesn’t work properly for dynamic libraries. It doesn’t help with Foundation either because it’s not part of the standard Swift library. Long story short, libpartout.so must be distributed side by side with the CMake binaries and the whole Swift runtime for the target architecture. You should find the runtime libraries for your current architecture at: $SWIFT_HOME/toolchains/&lt;swift_version&gt;/usr/lib/swift/&lt;platform_name&gt; With an additional dependency on libc++_shared.so for Android. Anyway, this Linux output should explain better what I’m talking about: ldd src/passepartout/submodules/partout/.build/debug/libpartout.so linux-vdso.so.1 (0x0000ec74cd2dc000) libswiftSwiftOnoneSupport.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswiftSwiftOnoneSupport.so (0x0000ec74ccc40000) libswiftCore.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswiftCore.so (0x0000ec74cc5a0000) libswift_Concurrency.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswift_Concurrency.so (0x0000ec74cc4f0000) libswift_StringProcessing.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswift_StringProcessing.so (0x0000ec74cc430000) libswift_RegexParser.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswift_RegexParser.so (0x0000ec74cc310000) libBlocksRuntime.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libBlocksRuntime.so (0x0000ec74cc2e0000) libdispatch.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libdispatch.so (0x0000ec74cc260000) libswiftDispatch.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswiftDispatch.so (0x0000ec74cc210000) libssl.so.3 =&gt; /lib/aarch64-linux-gnu/libssl.so.3 (0x0000ec74cc0f0000) libcrypto.so.3 =&gt; /lib/aarch64-linux-gnu/libcrypto.so.3 (0x0000ec74cbb60000) libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ec74cb990000) /lib/ld-linux-aarch64.so.1 (0x0000ec74cd2a0000) libstdc++.so.6 =&gt; /lib/aarch64-linux-gnu/libstdc++.so.6 (0x0000ec74cb6f0000) libm.so.6 =&gt; /lib/aarch64-linux-gnu/libm.so.6 (0x0000ec74cb630000) libgcc_s.so.1 =&gt; /lib/aarch64-linux-gnu/libgcc_s.so.1 (0x0000ec74cb5f0000) libswiftGlibc.so =&gt; /home/keeshux/.local/share/swiftly/toolchains/6.2.0/usr/lib/swift/linux/libswiftGlibc.so (0x0000ec74cb5c0000) libz.so.1 =&gt; /lib/aarch64-linux-gnu/libz.so.1 (0x0000ec74cb580000) libzstd.so.1 =&gt; /lib/aarch64-linux-gnu/libzstd.so.1 (0x0000ec74cb4c0000) Bottom line I assumed the readers to be familiar with build systems and CMake in particular, as the subject is vast and goes way beyond the scope of my article. I rather wanted to describe the design that worked for me to build a polyglot Swift library not only for non-Apple platforms, but also with multi-language, real-world dependencies. This is the real novelty, the one I’m so excited about, and the one that you would have a very hard time finding examples about. I’m bringing up proof that all this stuff works in Swift as Partout, the subject of this series, is not a toy project for the sake of a tutorial, but software in use by hundreds of thousands of users every day for streaming, privacy, remote work, and VPNs in general. Think about it for the bright future of the Swift language. In the next article, we’ll go through the integration of Partout in both Swift and non-Swift applications, with my Passepartout app being the living example of it.]]></summary></entry><entry><title type="html">Cross-platform Swift: Build system (pt. 1)</title><link href="https://davidederosa.com/cross-platform-swift/build-system-part-one/" rel="alternate" type="text/html" title="Cross-platform Swift: Build system (pt. 1)" /><published>2025-09-07T00:00:00+02:00</published><updated>2025-09-07T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-build-system-part-one</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/build-system-part-one/"><![CDATA[<p>There is a reason why it took me two months since the last post, and ironically it’s the very subject of this writing. I hate to say, but the build tools are the most painful and work-in-progress aspect of Swift, at least at the time of writing. Brace yourself.</p>

<h2 id="swiftpm-is-just-not-ready">SwiftPM is just not ready</h2>

<p>This post risks having a negative vibe, so I want to discuss solutions before problems. The first advice I can give if you want to build consistently across platforms is to <strong>avoid SwiftPM</strong>, except for Swift Testing. It’s just not fit for the role yet. XCFrameworks only work on Apple, and binary artifact bundles are on their way, but haven’t been released yet. If you need something that works <em>today</em>, get familiar with <code class="language-plaintext highlighter-rouge">swiftc</code> and <code class="language-plaintext highlighter-rouge">clang</code>, and switch to <strong>CMake with ninja</strong>. With CMake in place, Swift gains back the freedom and power it deserves. You take full control of what’s going on, and this will help you understand and fix the build issues that you’re bound to encounter.</p>

<p>At this point, you may come to realize how SwiftPM could lead you to a complex source hierarchy. The highly granular dependency model encouraged by the manifest is a neat abstraction, and works very well for modular Swift-only systems. But when you have to account for C/C++ targets, modulemaps, DocC, and external non-Swift libraries, it makes you want to jump off the nearest cliff without even a goodbye letter. In that case, making your source hierarchy flat and monolithic will make your life much easier. Two targets: one for Swift files, and one for C/C++ with a single modulemap.</p>

<p>Unfortunately, there’s one thing you might want SwiftPM for: the <a href="https://github.com/swiftlang/swift-sdk-generator">Swift SDKs</a>. For what it’s worth, I use a <a href="https://github.com/finagolfin/swift-android-sdk">Swift SDK for my Android builds</a>, and I have no idea if there’s a place for it in a CMake build, but I kind of doubt it. Nevertheless, given that Passepartout –and other consumers– still need Partout as a SwiftPM dependency, I’m okay with keeping both the Package.swift and CMake around for some time.</p>

<h2 id="the-swift-runtime">The Swift runtime</h2>

<p>There are two common ways to compile Swift files:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">swiftc</code></li>
  <li><code class="language-plaintext highlighter-rouge">swift build</code> (Swift Package Manager)</li>
</ul>

<p>The majority of Swift programmers, hardly use or tweak <code class="language-plaintext highlighter-rouge">swiftc</code> directly, which is similar to how one would use the <code class="language-plaintext highlighter-rouge">clang</code> or <code class="language-plaintext highlighter-rouge">gcc</code> C/C++ compilers. Over the years, the Xcode integration and the fast turnaround of SwiftPM execution from the command line made <code class="language-plaintext highlighter-rouge">swift build</code> the natural way to compile and link Swift projects, both standalone and inside Xcode.</p>

<p>This is all great, until it’s not. The lack of insight into what SwiftPM exactly does may be very problematic when we face a compiler or linker issue. However, pure Swift projects hardly hit major build issues, so don’t be surprised if the average iOS programmer doesn’t know how a Swift executable is generated or what it needs to run on a machine, because Apple devices come with the <strong>Swift runtime</strong> preinstalled.</p>

<p>The language “runtime” is a set of libraries that an executable requires to run on a specific architecture. Let me explain why I find this a serious blocker for Swift adoption.</p>

<h2 id="binary-distribution-is-impractical">Binary distribution is impractical</h2>

<p>Let’s pick Linux, for example, which on a typical modern desktop may come in arm64 or x86_64 flavors. Not only does this imply two runtimes to deal with for distributing our binaries, the Swift runtime is also split into <em>dozens</em> of files. If we close an eye on the footprint, this is still annoying, but less of a problem on platforms where the executable model is self-contained (iOS, macOS, Android, …). You could distribute a self-contained folder/installer on Linux, but it always feels off on a system where libraries are typically shared in <code class="language-plaintext highlighter-rouge">/usr/lib</code> for everybody.</p>

<p>Installing the Swift runtime with a package manager seems like a smoother solution, and saves us from the burden of manually bundling and maintaining the binaries for each architecture. To my knowledge, <a href="https://launchpad.net/ubuntu/+source/swiftlang">apt has a libswiftlang package</a>. I don’t know how maintained it is, because the apt package is at 6.0.3 with the latest toolchain being at 6.1.2. Not a 100% healthy sign, but not worrying either.</p>

<p>Still, this introduces a dependency, and forces you to either distribute your executable through a package manager, or include manual steps in order to fetch the proper Swift runtime, for the proper platform, and for the proper architecture. In that regard, I don’t like that <a href="https://swift.org">swift.org</a> doesn’t offer direct links to download runtime-only installers, like Java used to do with the Java Runtime Environment (JRE).</p>

<p>A more convenient solution for Linux was <a href="https://forums.swift.org/t/static-linking-on-linux-in-swift-5-3-1/41989">introduced in Swift 5.3.1 with static linking</a> in an attempt to match the self-contained approach of Golang, which is the state of the art for native multiplatform applications. Static linking to the stdlib is not as straightforward as running <code class="language-plaintext highlighter-rouge">go build</code>, but still.</p>

<h2 id="the-loneliness-of-the-other-platforms">The loneliness of the other platforms</h2>

<p>All things considered, the friction remains <em>very</em> real. Now, if this already sounds complicated, what if I told you that Linux is the <em>best</em> supported platform after Apple’s?</p>

<p>The weight of Windows and Android is on the shoulders of a few kind individuals, whose progress can be followed on the official Swift forums. For example, hard work is being done to bring <a href="https://forums.swift.org/t/upcoming-changes-to-windows-swift-sdks/81313">static linking on the Windows runtime</a> as of Swift 6.2 (unreleased yet), and a few months ago, <a href="https://forums.swift.org/t/announcing-the-android-workgroup/80666">an Android workgroup was made official</a>. Until then, Android development was mostly pushed by volunteers.</p>

<p>I’m all about supporting the maintainers of these exciting initiatives, and that’s why I took this winding path to experiment myself, but if you need something that works <em>right away</em> for building production software in Swift, you’d better assume that you’re on your own. There’s still work to be done to make the experience acceptable for the public domain, and Android builds in particular take <em>a lot</em> of manual steps, or way more than a lot.</p>

<p>At the end of the day, it depends on your goals. Personally, I was thrilled when I made Partout connect to a VPN on Android, with Linux syscalls over a Swift codebase that talks to Kotlin via JNI (!). That chill of “could this even work?”, because nobody had done it before. You hardly get that feeling with battle-tested languages, and if you like novelties, Swift is a greenfield that I would encourage you to explore and support.</p>

<h2 id="the-footprint-is-huge-by-default">The footprint is huge by default</h2>

<p>In a former article, I mentioned that <a href="/cross-platform-swift/core-libraries/">Foundation is not part of the standard library</a>, as in it’s not part of the essential runtime (libSwiftCore). In terms of size, the core runtime is not excessively concerning at around 10-15MB total. In fact, I’m way more annoyed by the fact that it’s made of tens of files. Well, add Foundation to the mix, and your runtime spikes to almost 100MB, with ICU contributing to around 40MB of it. And Foundation is hard to avoid. Frankly, that’s <em>insane</em>, but I still want to believe that this is the kind legacy from the Apple era of Swift. Let’s not forget that Foundation is bundled with any Apple OS.</p>

<p>My advice? If you’re starting from scratch, and footprint is a concern, never import Foundation, or maybe consider not using Swift at all. Go is more mature for the purpose of standalone outputs, easy to build, ubiquitous. If you want to stick with Swift or port your existing codebase to non-Apple, instead, consider dropping Foundation and reimplementing the parts that you need. With careful analysis, you might conclude that, despite its convenience, you don’t need it to the point of justifying a 100MB executable.</p>

<h2 id="bottom-line">Bottom line</h2>

<p>So, it’s 2025 and you want to make native cross-platform apps or libraries. Hard truth: if you want to make them <em>today</em>, Go is a wiser choice. If you want to use Swift, for now, prefer CMake over SwiftPM. Get your feet wet with the raw tooling to understand how Swift libraries are generated. Don’t be like me, keep a flat source hierarchy from the beginning.</p>

<p>In the next article, we’ll go through real examples of how I managed to build consistent outputs with SwiftPM/CMake on macOS, Linux, Windows, and even Android.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><category term="make" /><category term="cmake" /><summary type="html"><![CDATA[There is a reason why it took me two months since the last post, and ironically it’s the very subject of this writing. I hate to say, but the build tools are the most painful and work-in-progress aspect of Swift, at least at the time of writing. Brace yourself. SwiftPM is just not ready This post risks having a negative vibe, so I want to discuss solutions before problems. The first advice I can give if you want to build consistently across platforms is to avoid SwiftPM, except for Swift Testing. It’s just not fit for the role yet. XCFrameworks only work on Apple, and binary artifact bundles are on their way, but haven’t been released yet. If you need something that works today, get familiar with swiftc and clang, and switch to CMake with ninja. With CMake in place, Swift gains back the freedom and power it deserves. You take full control of what’s going on, and this will help you understand and fix the build issues that you’re bound to encounter. At this point, you may come to realize how SwiftPM could lead you to a complex source hierarchy. The highly granular dependency model encouraged by the manifest is a neat abstraction, and works very well for modular Swift-only systems. But when you have to account for C/C++ targets, modulemaps, DocC, and external non-Swift libraries, it makes you want to jump off the nearest cliff without even a goodbye letter. In that case, making your source hierarchy flat and monolithic will make your life much easier. Two targets: one for Swift files, and one for C/C++ with a single modulemap. Unfortunately, there’s one thing you might want SwiftPM for: the Swift SDKs. For what it’s worth, I use a Swift SDK for my Android builds, and I have no idea if there’s a place for it in a CMake build, but I kind of doubt it. Nevertheless, given that Passepartout –and other consumers– still need Partout as a SwiftPM dependency, I’m okay with keeping both the Package.swift and CMake around for some time. The Swift runtime There are two common ways to compile Swift files: swiftc swift build (Swift Package Manager) The majority of Swift programmers, hardly use or tweak swiftc directly, which is similar to how one would use the clang or gcc C/C++ compilers. Over the years, the Xcode integration and the fast turnaround of SwiftPM execution from the command line made swift build the natural way to compile and link Swift projects, both standalone and inside Xcode. This is all great, until it’s not. The lack of insight into what SwiftPM exactly does may be very problematic when we face a compiler or linker issue. However, pure Swift projects hardly hit major build issues, so don’t be surprised if the average iOS programmer doesn’t know how a Swift executable is generated or what it needs to run on a machine, because Apple devices come with the Swift runtime preinstalled. The language “runtime” is a set of libraries that an executable requires to run on a specific architecture. Let me explain why I find this a serious blocker for Swift adoption. Binary distribution is impractical Let’s pick Linux, for example, which on a typical modern desktop may come in arm64 or x86_64 flavors. Not only does this imply two runtimes to deal with for distributing our binaries, the Swift runtime is also split into dozens of files. If we close an eye on the footprint, this is still annoying, but less of a problem on platforms where the executable model is self-contained (iOS, macOS, Android, …). You could distribute a self-contained folder/installer on Linux, but it always feels off on a system where libraries are typically shared in /usr/lib for everybody. Installing the Swift runtime with a package manager seems like a smoother solution, and saves us from the burden of manually bundling and maintaining the binaries for each architecture. To my knowledge, apt has a libswiftlang package. I don’t know how maintained it is, because the apt package is at 6.0.3 with the latest toolchain being at 6.1.2. Not a 100% healthy sign, but not worrying either. Still, this introduces a dependency, and forces you to either distribute your executable through a package manager, or include manual steps in order to fetch the proper Swift runtime, for the proper platform, and for the proper architecture. In that regard, I don’t like that swift.org doesn’t offer direct links to download runtime-only installers, like Java used to do with the Java Runtime Environment (JRE). A more convenient solution for Linux was introduced in Swift 5.3.1 with static linking in an attempt to match the self-contained approach of Golang, which is the state of the art for native multiplatform applications. Static linking to the stdlib is not as straightforward as running go build, but still. The loneliness of the other platforms All things considered, the friction remains very real. Now, if this already sounds complicated, what if I told you that Linux is the best supported platform after Apple’s? The weight of Windows and Android is on the shoulders of a few kind individuals, whose progress can be followed on the official Swift forums. For example, hard work is being done to bring static linking on the Windows runtime as of Swift 6.2 (unreleased yet), and a few months ago, an Android workgroup was made official. Until then, Android development was mostly pushed by volunteers. I’m all about supporting the maintainers of these exciting initiatives, and that’s why I took this winding path to experiment myself, but if you need something that works right away for building production software in Swift, you’d better assume that you’re on your own. There’s still work to be done to make the experience acceptable for the public domain, and Android builds in particular take a lot of manual steps, or way more than a lot. At the end of the day, it depends on your goals. Personally, I was thrilled when I made Partout connect to a VPN on Android, with Linux syscalls over a Swift codebase that talks to Kotlin via JNI (!). That chill of “could this even work?”, because nobody had done it before. You hardly get that feeling with battle-tested languages, and if you like novelties, Swift is a greenfield that I would encourage you to explore and support. The footprint is huge by default In a former article, I mentioned that Foundation is not part of the standard library, as in it’s not part of the essential runtime (libSwiftCore). In terms of size, the core runtime is not excessively concerning at around 10-15MB total. In fact, I’m way more annoyed by the fact that it’s made of tens of files. Well, add Foundation to the mix, and your runtime spikes to almost 100MB, with ICU contributing to around 40MB of it. And Foundation is hard to avoid. Frankly, that’s insane, but I still want to believe that this is the kind legacy from the Apple era of Swift. Let’s not forget that Foundation is bundled with any Apple OS. My advice? If you’re starting from scratch, and footprint is a concern, never import Foundation, or maybe consider not using Swift at all. Go is more mature for the purpose of standalone outputs, easy to build, ubiquitous. If you want to stick with Swift or port your existing codebase to non-Apple, instead, consider dropping Foundation and reimplementing the parts that you need. With careful analysis, you might conclude that, despite its convenience, you don’t need it to the point of justifying a 100MB executable. Bottom line So, it’s 2025 and you want to make native cross-platform apps or libraries. Hard truth: if you want to make them today, Go is a wiser choice. If you want to use Swift, for now, prefer CMake over SwiftPM. Get your feet wet with the raw tooling to understand how Swift libraries are generated. Don’t be like me, keep a flat source hierarchy from the beginning. In the next article, we’ll go through real examples of how I managed to build consistent outputs with SwiftPM/CMake on macOS, Linux, Windows, and even Android.]]></summary></entry><entry><title type="html">The role of AI in losing care for our products</title><link href="https://davidederosa.com/2025/08/the-role-of-ai-in-losing-care-for-our-products/" rel="alternate" type="text/html" title="The role of AI in losing care for our products" /><published>2025-08-24T00:00:00+02:00</published><updated>2025-08-24T00:00:00+02:00</updated><id>https://davidederosa.com/2025/08/the-role-of-ai-in-losing-care-for-our-products</id><content type="html" xml:base="https://davidederosa.com/2025/08/the-role-of-ai-in-losing-care-for-our-products/"><![CDATA[<p>While I have nothing against “vibe coding” per se, I think it harms software-making in the way too many casual relationships do to the ability to make long-term bonds. In fact, it’s not about coding at all. It’s about building “care” for the product.</p>

<p>If I replace MVP with ONS in the equation, I notice eerie similarities. You build MVPs faster with AI, as you may get sex faster with a dating app, for example. You may even feel more accomplished, like non-programmers do when they “build things without having a clue”.</p>

<p>However, the easier you get ONS, the harder it becomes to commit to an intimate relationship. Similarly, the faster you build MVPs, the harder it gets to create software that lasts, because humans tend to care less for things they didn’t put real effort into.</p>

<p>I’m curious to see how many AI-gen software will survive the first year. LLMs produce write-only code by default, and it takes a decent amount of care to lead them in the right direction towards a well-designed product. Only someone who cares will step in and “take care of that”.</p>

<p>So, I disagree with the focus on bad code quality, that one is a much easier problem to solve. I’m rather worried about how indulging in AI may affect our ability to care about the things we create.</p>]]></content><author><name>Davide De Rosa</name></author><category term="llm" /><category term="ai" /><summary type="html"><![CDATA[While I have nothing against “vibe coding” per se, I think it harms software-making in the way too many casual relationships do to the ability to make long-term bonds. In fact, it’s not about coding at all. It’s about building “care” for the product. If I replace MVP with ONS in the equation, I notice eerie similarities. You build MVPs faster with AI, as you may get sex faster with a dating app, for example. You may even feel more accomplished, like non-programmers do when they “build things without having a clue”. However, the easier you get ONS, the harder it becomes to commit to an intimate relationship. Similarly, the faster you build MVPs, the harder it gets to create software that lasts, because humans tend to care less for things they didn’t put real effort into. I’m curious to see how many AI-gen software will survive the first year. LLMs produce write-only code by default, and it takes a decent amount of care to lead them in the right direction towards a well-designed product. Only someone who cares will step in and “take care of that”. So, I disagree with the focus on bad code quality, that one is a much easier problem to solve. I’m rather worried about how indulging in AI may affect our ability to care about the things we create.]]></summary></entry><entry><title type="html">Cross-platform Swift: C interop (pt. 2)</title><link href="https://davidederosa.com/cross-platform-swift/c-interop-part-two/" rel="alternate" type="text/html" title="Cross-platform Swift: C interop (pt. 2)" /><published>2025-07-10T00:00:00+02:00</published><updated>2025-07-10T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-c-interop-part-two</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/c-interop-part-two/"><![CDATA[<p>While writing C in a Swift context makes no difference at all, it takes a few tricks to reduce the friction in Swift code that embeds C routines. You will find tangible examples of what I describe here <a href="https://github.com/keeshux/cross-platform-swift">on my GitHub repository</a>. Let’s go through them together.</p>

<h2 id="the-mystique-of-swift-pointers">The mystique of Swift pointers</h2>

<p>Swift has often changed the way it interacts with C entities, especially around version 3 and 4, IIRC. It has changed so much that upgrading Xcode to a new minor version would likely break some code with obscure error messages. To this day, the ambiguity around Swift pointer types still beats me.</p>

<p>Have you ever noticed how many variants exist?</p>

<ul>
  <li><a href="https://developer.apple.com/documentation/swift/unsafepointer">UnsafePointer</a></li>
  <li><a href="https://developer.apple.com/documentation/swift/unsafebufferpointer">UnsafeBufferPointer</a></li>
  <li><a href="https://developer.apple.com/documentation/swift/unsaferawpointer">UnsafeRawPointer</a></li>
  <li><a href="https://developer.apple.com/documentation/swift/unsaferawbufferpointer">UnsafeRawBufferPointer</a></li>
</ul>

<p>Each of them with its mutable counterpart, totalling EIGHT pointer types. Don’t be offended, Swift, but this is ridiculously complex, and I hope that someday that part of the language will be properly simplified. It’s the single thing, hands down, that makes Swift/C interop unappealing.</p>

<p>Personally, I have a hard time getting them right, and find myself bruteforcing the Swift code until I get it to compile. Don’t even get me started on the <code class="language-plaintext highlighter-rouge">withUnsafeBytes()</code> variants and the horrendously deceptive compiler/LSP errors that they trigger. They are very similar to the ones you stumble upon in complex SwiftUI closures with generics, to get the idea.</p>

<p>Let me show you some lovely examples:</p>

<p><img src="/s/f/cross-platform-swift/c-interop-compile-01.png" alt="" /></p>

<p><img src="/s/f/cross-platform-swift/c-interop-compile-02.png" alt="" /></p>

<p><img src="/s/f/cross-platform-swift/c-interop-compile-03.png" alt="" /></p>

<p><img src="/s/f/cross-platform-swift/c-interop-compile-04.png" alt="" /></p>

<h2 id="unsafe-with-closures">Unsafe <code class="language-plaintext highlighter-rouge">with</code> closures</h2>

<p>When using <code class="language-plaintext highlighter-rouge">withUnsafeBytes()</code>, <code class="language-plaintext highlighter-rouge">withCString()</code>, and other similar closures, make sure to follow these ultimate 3 rules:</p>

<ul>
  <li><strong>Never ever let the closure arguments outlive the closure</strong>.</li>
  <li><strong>Never</strong>.</li>
  <li><strong>Ever</strong>.</li>
</ul>

<p>Thank me later. You’re welcome.</p>

<p>This is another clunky syntax of Swift. Especially if your C function requires multiple variables to be mapped to their “unsafe representation”, you may quickly end up with this beautiful accordion:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">var</span> <span class="nv">b</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">var</span> <span class="nv">c</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">a</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="n">pa</span> <span class="k">in</span>
    <span class="n">b</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="n">pb</span> <span class="k">in</span>
        <span class="n">c</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="n">pc</span> <span class="k">in</span>
            <span class="nf">my_demanding_c_function</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, disgusted by the indentation overflow, you might look for ways to make the code more linear, and naturally think of returning the pointers that the closures provide:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">pa</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">pb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">pc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">withUnsafeBytes</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
<span class="nf">my_demanding_c_function</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>
</code></pre></div></div>

<p>Much, much cleaner, only to find out that this code will crash, sooner or later, at some point of your life. They call it <em>unpredictable behavior</em>, and I guess it’s for the same reasons why you shouldn’t return a reference to a local variable. So, remember <em>the</em> rule, and kindly accept the nested closures. Or, keep reading.</p>

<h2 id="bridging-to-swift">Bridging to Swift</h2>

<p>Ironically, the above constructs are enough to minimize or even discourage the use of C in Swift. The time I wasted on Swift pointers made me constantly reconsider the balance between Swift and C code %, in that exposing C pointers to Swift was so frustrating that I’d rather write the whole logic in C, and let Swift be a thin wrapper. After all, it’s the best approach because going back and forth from and to Swift/C types is very inconvenient. Why would you ever use a bare <code class="language-plaintext highlighter-rouge">memcpy()</code> or <code class="language-plaintext highlighter-rouge">strlen()</code> in Swift? There are better, native alternatives.</p>

<p>The point of C interop is to perform the low-level logic in C files, and only expose in/out types that are easier to funnel to Swift for use at higher levels of abstraction, especially if you make good use of the <code class="language-plaintext highlighter-rouge">_Nullable</code> and <code class="language-plaintext highlighter-rouge">_Nonnull</code> clang qualifiers.</p>

<p>All in all, Swift bridges C <code class="language-plaintext highlighter-rouge">struct</code> as if it were a Swift value type, and pointers to <code class="language-plaintext highlighter-rouge">struct</code> are naturally mapped to <code class="language-plaintext highlighter-rouge">UnsafePointer&lt;T&gt;</code> or <code class="language-plaintext highlighter-rouge">UnsafeMutablePointer&lt;T&gt;</code> according to their <code class="language-plaintext highlighter-rouge">const</code> modifier. <code class="language-plaintext highlighter-rouge">enum</code> and <code class="language-plaintext highlighter-rouge">union</code> also behave pretty much the same way.</p>

<p>So, what’s the matter? Why would one need more than this? Well, because everything is cool until you hit pointers, strings, and memory management.</p>

<h2 id="opaquepointer">OpaquePointer</h2>

<p>Sure, a C <code class="language-plaintext highlighter-rouge">struct</code> is nicely bridged to Swift, until it has less linear (yet super common) fields like:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span> <span class="o">**</span><span class="n">ptr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">**</span><span class="n">matrix</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_cool_struct</span><span class="p">;</span>
</code></pre></div></div>

<p>Good luck with the bridged Swift version of this structure, and good luck to manage its memory layout properly.</p>

<p>But this is when I casually discovered the magic wand, the ultimate structure for C objects in Swift: <a href="https://developer.apple.com/documentation/swift/opaquepointer">OpaquePointer</a>.</p>

<p><img src="/s/f/cross-platform-swift/c-interop-opaque-pointers.jpg" alt="Courtesy of Reddit" /></p>

<p>Opaque pointers are a popular way to attain OOP-like encapsulation in C. You write a <em>forward declaration</em> in a .h header, then the full definition in a .c file. By doing so, the type internals are only exposed to the .c file that needs them to implement its logic. Externally, the pointers are treated as generic I/O handles, and Swift can’t see through them because it can only bridge what it sees in the C headers, i.e. a shallow type name. For the record, Objective-C can do this with <code class="language-plaintext highlighter-rouge">@class MyType</code>.</p>

<h3 id="the-benefits-of-opaquepointer">The benefits of OpaquePointer</h3>

<p>For example, if we have this structure in a C header:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// .h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">tls_channel_options</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">opt</span><span class="p">;</span>
    <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">ssl_ctx</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">buf_cipher</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">buf_plain</span><span class="p">;</span>

    <span class="n">SSL</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">ssl</span><span class="p">;</span>
    <span class="n">BIO</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">bio_plain</span><span class="p">;</span>
    <span class="n">BIO</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">bio_cipher_in</span><span class="p">;</span>
    <span class="n">BIO</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">bio_cipher_out</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">is_connected</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tls_channel</span><span class="p">;</span>
</code></pre></div></div>

<p>and return e.g. <code class="language-plaintext highlighter-rouge">tls_channel *</code> from a function, its type will map to <code class="language-plaintext highlighter-rouge">UnsafeMutablePointer&lt;tls_channel&gt;</code> in Swift, and we’ll be able to access its fields with <code class="language-plaintext highlighter-rouge">.pointee</code>. We don’t need or want that level of detail, those are C concerns.</p>

<p>Therefore, we split the definitions across two files. The header with a forward pointer declaration:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// .h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tls_channel</span> <span class="o">*</span><span class="n">tls_channel_ctx</span><span class="p">;</span>
</code></pre></div></div>

<p>and the .c file, with the full definition, mind the lack of <code class="language-plaintext highlighter-rouge">typedef</code> here:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// .c</span>
<span class="k">struct</span> <span class="n">tls_channel</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">tls_channel_options</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">opt</span><span class="p">;</span>
    <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">_Nonnull</span> <span class="n">ssl_ctx</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>At this point, we replace <code class="language-plaintext highlighter-rouge">tls_channel *</code> with the <code class="language-plaintext highlighter-rouge">tls_channel_ctx</code> alias:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// before</span>
<span class="n">tls_channel</span> <span class="o">*</span><span class="nf">tls_create_func</span><span class="p">();</span>

<span class="c1">// after</span>
<span class="n">tls_channel_ctx</span> <span class="nf">tls_create_func</span><span class="p">();</span>
</code></pre></div></div>

<p>and Swift will consider the returned object to be of <code class="language-plaintext highlighter-rouge">OpaquePointer</code> type.</p>

<p>Benefits:</p>

<ul>
  <li>No unsafe Swift pointers involved ever again</li>
  <li>No unsafe <code class="language-plaintext highlighter-rouge">with</code> closures, you pass the object as is to C functions from Swift</li>
  <li>The C layer is the only responsible of the object, and Swift cannot mess with it</li>
</ul>

<p>Granted, it’s not a one-size-fits-it-all, but for complex C objects that need to cross the Swift boundary often, opaque pointers may be a good bet.</p>

<p><img src="/s/f/cross-platform-swift/c-interop-opaque-pointers-example.png" alt="Example in Swift" /></p>

<h2 id="debugging">Debugging</h2>

<p>Talking about the Xcode debugger, it is generally able to debug C code called from Swift without issues. Not that I pushed this to the limit, but so far I’ve only noticed two places where the debugger is unhelpful.</p>

<p>For example, due to their very nature, you don’t get to see what opaque pointers point to in Swift code. However, opaque pointers encapsulate private data, so a logical deduction would be that you’d rather put your breakpoint in C files, and let Swift treat them as a black box.</p>

<p>The other situation is <code class="language-plaintext highlighter-rouge">inline</code> functions, where the Xcode debugger clearly struggles to step in (with reason?).</p>

<h2 id="bottom-line">Bottom line</h2>

<p>Interacting with Swift pointers is painful, but we can make our lives easier with some workarounds. The friction is directly proportional to the surface we expose to Swift, so we need to hide the C internals as much as possible, and minimize the roundtrips across languages. Use opaque pointers when types become complex.</p>

<p>Now that we learned a few tricks about C interop, we can go back to the SwiftPM manifest to manage multiple, alternative implementations. See you in the next article.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><summary type="html"><![CDATA[While writing C in a Swift context makes no difference at all, it takes a few tricks to reduce the friction in Swift code that embeds C routines. You will find tangible examples of what I describe here on my GitHub repository. Let’s go through them together. The mystique of Swift pointers Swift has often changed the way it interacts with C entities, especially around version 3 and 4, IIRC. It has changed so much that upgrading Xcode to a new minor version would likely break some code with obscure error messages. To this day, the ambiguity around Swift pointer types still beats me. Have you ever noticed how many variants exist? UnsafePointer UnsafeBufferPointer UnsafeRawPointer UnsafeRawBufferPointer Each of them with its mutable counterpart, totalling EIGHT pointer types. Don’t be offended, Swift, but this is ridiculously complex, and I hope that someday that part of the language will be properly simplified. It’s the single thing, hands down, that makes Swift/C interop unappealing. Personally, I have a hard time getting them right, and find myself bruteforcing the Swift code until I get it to compile. Don’t even get me started on the withUnsafeBytes() variants and the horrendously deceptive compiler/LSP errors that they trigger. They are very similar to the ones you stumble upon in complex SwiftUI closures with generics, to get the idea. Let me show you some lovely examples: Unsafe with closures When using withUnsafeBytes(), withCString(), and other similar closures, make sure to follow these ultimate 3 rules: Never ever let the closure arguments outlive the closure. Never. Ever. Thank me later. You’re welcome. This is another clunky syntax of Swift. Especially if your C function requires multiple variables to be mapped to their “unsafe representation”, you may quickly end up with this beautiful accordion: var a = ... var b = ... var c = ... a.withUnsafeBytes { pa in b.withUnsafeBytes { pb in c.withUnsafeBytes { pc in my_demanding_c_function(pa, pb, pc) } } } Then, disgusted by the indentation overflow, you might look for ways to make the code more linear, and naturally think of returning the pointers that the closures provide: let pa = a.withUnsafeBytes { $0 } let pb = b.withUnsafeBytes { $0 } let pc = c.withUnsafeBytes { $0 } my_demanding_c_function(pa, pb, pc) Much, much cleaner, only to find out that this code will crash, sooner or later, at some point of your life. They call it unpredictable behavior, and I guess it’s for the same reasons why you shouldn’t return a reference to a local variable. So, remember the rule, and kindly accept the nested closures. Or, keep reading. Bridging to Swift Ironically, the above constructs are enough to minimize or even discourage the use of C in Swift. The time I wasted on Swift pointers made me constantly reconsider the balance between Swift and C code %, in that exposing C pointers to Swift was so frustrating that I’d rather write the whole logic in C, and let Swift be a thin wrapper. After all, it’s the best approach because going back and forth from and to Swift/C types is very inconvenient. Why would you ever use a bare memcpy() or strlen() in Swift? There are better, native alternatives. The point of C interop is to perform the low-level logic in C files, and only expose in/out types that are easier to funnel to Swift for use at higher levels of abstraction, especially if you make good use of the _Nullable and _Nonnull clang qualifiers. All in all, Swift bridges C struct as if it were a Swift value type, and pointers to struct are naturally mapped to UnsafePointer&lt;T&gt; or UnsafeMutablePointer&lt;T&gt; according to their const modifier. enum and union also behave pretty much the same way. So, what’s the matter? Why would one need more than this? Well, because everything is cool until you hit pointers, strings, and memory management. OpaquePointer Sure, a C struct is nicely bridged to Swift, until it has less linear (yet super common) fields like: typedef struct { char str[32]; uint16_t *buf; const void (*)(char **ptr); int **matrix; } my_cool_struct; Good luck with the bridged Swift version of this structure, and good luck to manage its memory layout properly. But this is when I casually discovered the magic wand, the ultimate structure for C objects in Swift: OpaquePointer. Opaque pointers are a popular way to attain OOP-like encapsulation in C. You write a forward declaration in a .h header, then the full definition in a .c file. By doing so, the type internals are only exposed to the .c file that needs them to implement its logic. Externally, the pointers are treated as generic I/O handles, and Swift can’t see through them because it can only bridge what it sees in the C headers, i.e. a shallow type name. For the record, Objective-C can do this with @class MyType. The benefits of OpaquePointer For example, if we have this structure in a C header: // .h typedef struct { const tls_channel_options *_Nonnull opt; SSL_CTX *_Nonnull ssl_ctx; size_t buf_len; uint8_t *_Nonnull buf_cipher; uint8_t *_Nonnull buf_plain; SSL *_Nonnull ssl; BIO *_Nonnull bio_plain; BIO *_Nonnull bio_cipher_in; BIO *_Nonnull bio_cipher_out; bool is_connected; } tls_channel; and return e.g. tls_channel * from a function, its type will map to UnsafeMutablePointer&lt;tls_channel&gt; in Swift, and we’ll be able to access its fields with .pointee. We don’t need or want that level of detail, those are C concerns. Therefore, we split the definitions across two files. The header with a forward pointer declaration: // .h typedef struct tls_channel *tls_channel_ctx; and the .c file, with the full definition, mind the lack of typedef here: // .c struct tls_channel { const tls_channel_options *_Nonnull opt; SSL_CTX *_Nonnull ssl_ctx; // ... }; At this point, we replace tls_channel * with the tls_channel_ctx alias: // before tls_channel *tls_create_func(); // after tls_channel_ctx tls_create_func(); and Swift will consider the returned object to be of OpaquePointer type. Benefits: No unsafe Swift pointers involved ever again No unsafe with closures, you pass the object as is to C functions from Swift The C layer is the only responsible of the object, and Swift cannot mess with it Granted, it’s not a one-size-fits-it-all, but for complex C objects that need to cross the Swift boundary often, opaque pointers may be a good bet. Debugging Talking about the Xcode debugger, it is generally able to debug C code called from Swift without issues. Not that I pushed this to the limit, but so far I’ve only noticed two places where the debugger is unhelpful. For example, due to their very nature, you don’t get to see what opaque pointers point to in Swift code. However, opaque pointers encapsulate private data, so a logical deduction would be that you’d rather put your breakpoint in C files, and let Swift treat them as a black box. The other situation is inline functions, where the Xcode debugger clearly struggles to step in (with reason?). Bottom line Interacting with Swift pointers is painful, but we can make our lives easier with some workarounds. The friction is directly proportional to the surface we expose to Swift, so we need to hide the C internals as much as possible, and minimize the roundtrips across languages. Use opaque pointers when types become complex. Now that we learned a few tricks about C interop, we can go back to the SwiftPM manifest to manage multiple, alternative implementations. See you in the next article.]]></summary></entry><entry><title type="html">Cross-platform Swift: C interop (pt. 1)</title><link href="https://davidederosa.com/cross-platform-swift/c-interop-part-one/" rel="alternate" type="text/html" title="Cross-platform Swift: C interop (pt. 1)" /><published>2025-07-09T00:00:00+02:00</published><updated>2025-07-09T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-c-interop-part-one</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/c-interop-part-one/"><![CDATA[<p>This is where the fun begins. <a href="https://github.com/partout-io/partout">Partout</a>, the library I talk about in this series, is a networking library. As such, there are places where code control and performance are paramount. The integration of Swift with the C language for low-level routines is neat, and SwiftPM makes it very easy to mix Swift and C code as if they were the same thing.</p>

<h2 id="the-dangers-of-apple-mix-and-match">The dangers of Apple “Mix and Match”</h2>

<p><img src="/s/f/cross-platform-swift/c-interop-objc-tinky-winky.jpg" alt="ObjC is the Tinky Winky hand" /></p>

<p>I said “mix Swift and C code”, but I should have said “Swift, C, and Objective-C code”. Given that Swift was born off the ribs of Objective-C and the everlasting NeXSTEP library –I know you love that ubiquitous <code class="language-plaintext highlighter-rouge">NS</code> prefix–, it still owes a big legacy to that system. Since the beginning, Apple offered great tools to make <a href="https://developer.apple.com/documentation/swift/importing-objective-c-into-swift">the migration from ObjC to Swift</a> as seamless as possible. In fact, the process has been so smooth that you may have a hard time spotting the Objective-C entities of a Swift codebase.</p>

<p>While this is amazing for Apple-oriented software with plenty of legacy, this is no less than a disgrace when you port Swift elsewhere, because <a href="/cross-platform-swift/#2-objc-no-thanks">Objective-C is not available to Swift</a> out of the Apple ecosystem. At least, not easily <em>at all</em>.</p>

<h2 id="embrace-the-power-of-c">Embrace the power of C</h2>

<p>The mix-and-match transition to Swift may lead your codebase to a place where it’s very difficult to gauge the extent of the Objective-C legacy. Why is this important? Because if your intent is going cross-platform, you’d better port all your Objective-C code to good old C. The alternative is manually linking against <a href="https://www.gnustep.org/">GNUstep</a>, but it’s niche GPL software, and adds unnecessary complexity to keep around a language that is already obsolete.</p>

<p>In my case, the low-level part of my OpenVPN implementation in Partout was written in Objective-C plus OpenSSL, so I decided it was time to <a href="https://github.com/passepartoutvpn/partout/milestone/4?closed=1">patiently write a new C version</a>.</p>

<p>You have no idea how thrilled I am that <strong>this new Swift/C implementation now works on Apple, Windows, Linux, and Android</strong>!</p>

<p>It took me a couple of weeks to have a successful connection over the new code, and not only was it more <em>pleasant</em> (Objective-C is not praised for its beauty), it was also significantly <em>faster</em>. The image below shows a speed test comparing the performance of my C (1) and ObjC (2) implementations of the OpenVPN protocol over the same 5G connection.</p>

<p>Can I finally mention the joy of using C again after years of high-level programming?</p>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpartout%2Fblob%2F66f3ed5c01c8d357a7b625a1067f19f368698124%2FSources%2FCrypto%2FOpenSSL_ObjC%2FCryptoAEAD.m%23L37-L58&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpartout%2Fblob%2F66f3ed5c01c8d357a7b625a1067f19f368698124%2FSources%2FCrypto%2FOpenSSL_C%2Fcrypto_aead.c%23L26-L42&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<p><img src="/s/f/cross-platform-swift/c-interop-speed-test.png" alt="OpenVPN over C versus ObjC" /></p>

<h2 id="let-countless-options-unfold">Let countless options unfold</h2>

<p>As you dig into C interop, you realize how many things you can do with Swift in both an abstract and performant fashion. WWDC 2024 even introduced the <a href="https://www.swift.org/get-started/embedded/">Embedded Swift</a> mode to <em>really</em> go thin and low-level, and C is the natural choice when it comes to communicating with an operating system API, or non-Swift libraries.</p>

<p>At a later stage, we’ll have to face the complications of distributing the Swift runtime, but having C at disposal may dramatically reduce the impact of third-party dependencies, including those Swift itself relies on. Let me anticipate a few examples:</p>

<ul>
  <li>The burden of Foundation, or even Concurrency, may be avoided with a tailored C API for our specific domain.</li>
  <li>The WireGuard backend, that Partout currently integrates via <a href="https://github.com/WireGuard/wireguard-go">wireguard-go</a>, can communicate with the Linux/Windows kernel module instead.</li>
  <li>If the footprint is important, the OpenSSL dependency may be replaced with OS APIs, or used in SwiftPM as a shared library. This is common on Linux.</li>
</ul>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpartout%2Fblob%2F66f3ed5c01c8d357a7b625a1067f19f368698124%2FPackage.swift%23L334-L346&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<h2 id="bottom-line">Bottom line</h2>

<p>C is a first-class citizen in the Swift ecosystem, and it’s the door to literally everything about a device. Keep enjoying the convenience of the modern Swift abstractions, but don’t fear the power of C when necessary, because C code compiles everywhere with little to no modifications. Some stuff is incredibly easier in C than Swift.</p>

<p>In the next article, I’ll show you how to survive the deceptive complexity of Swift/C bridging.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><summary type="html"><![CDATA[This is where the fun begins. Partout, the library I talk about in this series, is a networking library. As such, there are places where code control and performance are paramount. The integration of Swift with the C language for low-level routines is neat, and SwiftPM makes it very easy to mix Swift and C code as if they were the same thing. The dangers of Apple “Mix and Match” I said “mix Swift and C code”, but I should have said “Swift, C, and Objective-C code”. Given that Swift was born off the ribs of Objective-C and the everlasting NeXSTEP library –I know you love that ubiquitous NS prefix–, it still owes a big legacy to that system. Since the beginning, Apple offered great tools to make the migration from ObjC to Swift as seamless as possible. In fact, the process has been so smooth that you may have a hard time spotting the Objective-C entities of a Swift codebase. While this is amazing for Apple-oriented software with plenty of legacy, this is no less than a disgrace when you port Swift elsewhere, because Objective-C is not available to Swift out of the Apple ecosystem. At least, not easily at all. Embrace the power of C The mix-and-match transition to Swift may lead your codebase to a place where it’s very difficult to gauge the extent of the Objective-C legacy. Why is this important? Because if your intent is going cross-platform, you’d better port all your Objective-C code to good old C. The alternative is manually linking against GNUstep, but it’s niche GPL software, and adds unnecessary complexity to keep around a language that is already obsolete. In my case, the low-level part of my OpenVPN implementation in Partout was written in Objective-C plus OpenSSL, so I decided it was time to patiently write a new C version. You have no idea how thrilled I am that this new Swift/C implementation now works on Apple, Windows, Linux, and Android! It took me a couple of weeks to have a successful connection over the new code, and not only was it more pleasant (Objective-C is not praised for its beauty), it was also significantly faster. The image below shows a speed test comparing the performance of my C (1) and ObjC (2) implementations of the OpenVPN protocol over the same 5G connection. Can I finally mention the joy of using C again after years of high-level programming? Let countless options unfold As you dig into C interop, you realize how many things you can do with Swift in both an abstract and performant fashion. WWDC 2024 even introduced the Embedded Swift mode to really go thin and low-level, and C is the natural choice when it comes to communicating with an operating system API, or non-Swift libraries. At a later stage, we’ll have to face the complications of distributing the Swift runtime, but having C at disposal may dramatically reduce the impact of third-party dependencies, including those Swift itself relies on. Let me anticipate a few examples: The burden of Foundation, or even Concurrency, may be avoided with a tailored C API for our specific domain. The WireGuard backend, that Partout currently integrates via wireguard-go, can communicate with the Linux/Windows kernel module instead. If the footprint is important, the OpenSSL dependency may be replaced with OS APIs, or used in SwiftPM as a shared library. This is common on Linux. Bottom line C is a first-class citizen in the Swift ecosystem, and it’s the door to literally everything about a device. Keep enjoying the convenience of the modern Swift abstractions, but don’t fear the power of C when necessary, because C code compiles everywhere with little to no modifications. Some stuff is incredibly easier in C than Swift. In the next article, I’ll show you how to survive the deceptive complexity of Swift/C bridging.]]></summary></entry><entry><title type="html">Cross-platform Swift: Platform specifics</title><link href="https://davidederosa.com/cross-platform-swift/platform-specifics/" rel="alternate" type="text/html" title="Cross-platform Swift: Platform specifics" /><published>2025-06-30T00:00:00+02:00</published><updated>2025-06-30T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-platform-specifics</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/platform-specifics/"><![CDATA[<p>Very few developers treat the SwiftPM manifest, i.e. the <code class="language-plaintext highlighter-rouge">Package.swift</code> file, as what its extension suggests. If you are used to enumerate static products and targets, remember that the SwiftPM manifest is a fully legit Swift program, and as such it allows for plenty of control.</p>

<h2 id="conditionals-in-packageswift">Conditionals in Package.swift</h2>

<p>In a library whose aim is to target multiple platforms, and try different paths along the way, a flexible manifest is of great help. Partout uses generic Swift routines overall, but in some areas it needs to differentiate how things are done based on the platform it’s running on.</p>

<p>Think of:</p>

<ul>
  <li>DNS resolution (CFHost vs POSIX)</li>
  <li>Pseudo-random number generation (SecRandom vs getrandom)</li>
  <li>Access to the filesystem (FileManager vs FILE *)</li>
</ul>

<p>In some cases, even provide additional behavior that is not available on other platforms. If you started our Swift library on Apple platforms, like it’s often the case, you may have used plenty of frameworks that are tighly bound to Apple. Examples:</p>

<ul>
  <li>UserDefaults</li>
  <li>The keychain</li>
  <li>iCloud</li>
  <li>Camera</li>
  <li>…</li>
</ul>

<h2 id="building-on-non-apple">Building on non-Apple</h2>

<p>While it’s true that the <code class="language-plaintext highlighter-rouge">Foundation</code> framework may provide some platform-agnostic API (e.g. <code class="language-plaintext highlighter-rouge">UserDefaults</code>), it’s better to take full control of what’s being distributed based on our choices. If you care to split platform-specific code into separate targets, you can leverage the <code class="language-plaintext highlighter-rouge">condition</code> parameter of a dependency to fine-tune per-platform dependencies:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"SomeMultiCode"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"SomeiOSDep"</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">iOS</span><span class="p">])),</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"SomeWindowsDep"</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">windows</span><span class="p">])),</span>
        <span class="c1">// ...</span>
        <span class="c1">// same with .product</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Invoking <code class="language-plaintext highlighter-rouge">swift build --target &lt;some&gt;</code> will comply with the platform conditionals, whereas this (still) seems to be a problem for tests. That’s because SwiftPM attempts to build all targets regardless of the conditionals, then compose the filtered targets to assemble the final products, whereas it shouldn’t build some targets in the first place.</p>

<p>A mitigation for this problem is to wrap conditional code in a <code class="language-plaintext highlighter-rouge">canImport</code> condition:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// make sure that the import is available</span>
<span class="cp">#if canImport(Security)</span>
<span class="kd">import</span> <span class="kt">Security</span>

<span class="c1">// do stuff with the Apple Security framework</span>
<span class="cp">#endif</span>
</code></pre></div></div>

<p>This is acceptable inside the library, but how should consumers deal with all these inconvenient differences?</p>

<h2 id="dependency-factory">Dependency factory</h2>

<p>A simple solution to avoid conditionals in consumer apps is the use of a <em>factory</em> to instantiate the right dependencies for our environment. The factory would internally pick the suitable implementation for the current platform, lifting the burden of the choice from the user of the library.</p>

<p>Imagine that we want to provide a common interface for the persistent storage of the library. A natural choice on Apple would be Core Data, and maybe Realm or plain SQLite on Windows and Linux. Furthermore, we may want to support CloudKit synchronization on Apple devices, and omit that feature elsewhere.</p>

<p>In Package.swift:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyPersistence"</span>
<span class="p">),</span>
<span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyApplePersistence"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">"MyPersistence"</span><span class="p">]</span>
<span class="p">),</span>
<span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyOtherPersistence"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">"MyPersistence"</span><span class="p">]</span>
<span class="p">),</span>
<span class="o">.</span><span class="nf">target</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyLibrary"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"MyApplePersistence"</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">iOS</span><span class="p">,</span> <span class="o">.</span><span class="n">macOS</span><span class="p">,</span> <span class="o">.</span><span class="n">tvOS</span><span class="p">,</span> <span class="o">.</span><span class="n">watchOS</span><span class="p">])),</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"MyOtherPersistence"</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">windows</span><span class="p">,</span> <span class="o">.</span><span class="n">linux</span><span class="p">,</span> <span class="o">.</span><span class="n">android</span><span class="p">])),</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">MyPersistence</code> we declare the generic persistence API:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Persistence</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">supportsSynchronization</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="kd">func</span> <span class="n">save</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="k">throws</span>
<span class="p">}</span>
</code></pre></div></div>

<p>that we then implement in <code class="language-plaintext highlighter-rouge">CoreDataPersistence</code> with Core Data, in the <code class="language-plaintext highlighter-rouge">MyApplePersistence</code> target:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">CoreData</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">CoreDataPersistence</span><span class="p">:</span> <span class="kt">Persistence</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">supportsSynchronization</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">save</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and <code class="language-plaintext highlighter-rouge">RealmPersistence</code> with Realm, in the <code class="language-plaintext highlighter-rouge">MyOtherPersistence</code> target:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Realm</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">RealmPersistence</span><span class="p">:</span> <span class="kt">Persistence</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">supportsSynchronization</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="kc">false</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">save</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the <code class="language-plaintext highlighter-rouge">MyLibrary</code> umbrella target:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Factories</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">PersistenceFactory</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">newPersistence</span><span class="p">(</span><span class="n">at</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Persistence</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Factories</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">persistence</span> <span class="o">=</span> <span class="kt">PersistenceFactoryImpl</span><span class="p">()</span>
<span class="p">}</span>

<span class="cp">#if canImport(MyApplePersistence)</span>

<span class="c1">// uses Core Data</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">PersistenceFactoryImpl</span><span class="p">:</span> <span class="kt">PersistenceFactory</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">newPersistence</span><span class="p">(</span><span class="n">at</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Persistence</span> <span class="p">{</span>
        <span class="k">try</span> <span class="kt">CoreDataPersistence</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="n">path</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#elseif canImport(MyOtherPersistence)</span>

<span class="c1">// uses Realm</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">PersistenceFactoryImpl</span><span class="p">:</span> <span class="kt">PersistenceFactory</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">newPersistence</span><span class="p">(</span><span class="n">at</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Persistence</span> <span class="p">{</span>
        <span class="k">try</span> <span class="kt">RealmPersistence</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="n">path</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="c1">// unsupported platform</span>

<span class="cp">#endif</span>
</code></pre></div></div>

<p>Finally, in the consumer app we would do this regardless of the operating system:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">path</span> <span class="o">=</span> <span class="s">"SomeFile.db"</span>
    <span class="k">let</span> <span class="nv">persistence</span> <span class="o">=</span> <span class="kt">Factories</span><span class="o">.</span><span class="n">persistence</span><span class="o">.</span><span class="nf">newPersistence</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">path</span><span class="p">)</span>
    <span class="c1">// ...</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Supports synchronization: </span><span class="se">\(</span><span class="n">persistence</span><span class="o">.</span><span class="n">supportsSynchronization</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">persistence</span><span class="o">.</span><span class="nf">save</span><span class="p">(</span><span class="s">"SomeString"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The library would just take care of the different implementations.</p>

<h2 id="bottom-line">Bottom line</h2>

<p>It’s easy to overcome the platform differences with SwiftPM conditionals and simple design patterns. If you need even more customizations, don’t be afraid to tweak the manifest further because it’s good old Swift, not static YAML. Even just an <code class="language-plaintext highlighter-rouge">if</code>, or reading environment variables with <a href="https://developer.apple.com/documentation/foundation/processinfo"><code class="language-plaintext highlighter-rouge">ProcessInfo</code></a>, may do wonders and resolve convoluted dynamic package layouts. Yes, in <code class="language-plaintext highlighter-rouge">FOOBAR="value" swift build</code>, the <code class="language-plaintext highlighter-rouge">FOOBAR</code> variable is reachable from your manifest!</p>

<p>In the next article, we’ll start the long but inevitable journey of Swift interoperability with C and other languages.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><summary type="html"><![CDATA[Very few developers treat the SwiftPM manifest, i.e. the Package.swift file, as what its extension suggests. If you are used to enumerate static products and targets, remember that the SwiftPM manifest is a fully legit Swift program, and as such it allows for plenty of control. Conditionals in Package.swift In a library whose aim is to target multiple platforms, and try different paths along the way, a flexible manifest is of great help. Partout uses generic Swift routines overall, but in some areas it needs to differentiate how things are done based on the platform it’s running on. Think of: DNS resolution (CFHost vs POSIX) Pseudo-random number generation (SecRandom vs getrandom) Access to the filesystem (FileManager vs FILE *) In some cases, even provide additional behavior that is not available on other platforms. If you started our Swift library on Apple platforms, like it’s often the case, you may have used plenty of frameworks that are tighly bound to Apple. Examples: UserDefaults The keychain iCloud Camera … Building on non-Apple While it’s true that the Foundation framework may provide some platform-agnostic API (e.g. UserDefaults), it’s better to take full control of what’s being distributed based on our choices. If you care to split platform-specific code into separate targets, you can leverage the condition parameter of a dependency to fine-tune per-platform dependencies: .target( name: "SomeMultiCode", dependencies: [ .target(name: "SomeiOSDep", condition: .when(platforms: [.iOS])), .target(name: "SomeWindowsDep", condition: .when(platforms: [.windows])), // ... // same with .product ] ) Invoking swift build --target &lt;some&gt; will comply with the platform conditionals, whereas this (still) seems to be a problem for tests. That’s because SwiftPM attempts to build all targets regardless of the conditionals, then compose the filtered targets to assemble the final products, whereas it shouldn’t build some targets in the first place. A mitigation for this problem is to wrap conditional code in a canImport condition: // make sure that the import is available #if canImport(Security) import Security // do stuff with the Apple Security framework #endif This is acceptable inside the library, but how should consumers deal with all these inconvenient differences? Dependency factory A simple solution to avoid conditionals in consumer apps is the use of a factory to instantiate the right dependencies for our environment. The factory would internally pick the suitable implementation for the current platform, lifting the burden of the choice from the user of the library. Imagine that we want to provide a common interface for the persistent storage of the library. A natural choice on Apple would be Core Data, and maybe Realm or plain SQLite on Windows and Linux. Furthermore, we may want to support CloudKit synchronization on Apple devices, and omit that feature elsewhere. In Package.swift: .target( name: "MyPersistence" ), .target( name: "MyApplePersistence", dependencies: ["MyPersistence"] ), .target( name: "MyOtherPersistence", dependencies: ["MyPersistence"] ), .target( name: "MyLibrary", dependencies: [ .target(name: "MyApplePersistence", condition: .when(platforms: [.iOS, .macOS, .tvOS, .watchOS])), .target(name: "MyOtherPersistence", condition: .when(platforms: [.windows, .linux, .android])), ] ) In MyPersistence we declare the generic persistence API: public protocol Persistence { var supportsSynchronization: Bool { get } func save&lt;T&gt;(_ object: T) throws } that we then implement in CoreDataPersistence with Core Data, in the MyApplePersistence target: import CoreData public final class CoreDataPersistence: Persistence { init(path: String) { // ... } var supportsSynchronization: Bool { true } func save&lt;T&gt;(_ object: T) throws { // ... } } and RealmPersistence with Realm, in the MyOtherPersistence target: import Realm public final class RealmPersistence: Persistence { init(path: String) { // ... } var supportsSynchronization: Bool { false } func save&lt;T&gt;(_ object: T) throws { // ... } } In the MyLibrary umbrella target: public enum Factories { } public protocol PersistenceFactory { func newPersistence(at path: String) throws -&gt; Persistence } extension Factories { public static let persistence = PersistenceFactoryImpl() } #if canImport(MyApplePersistence) // uses Core Data private final class PersistenceFactoryImpl: PersistenceFactory { func newPersistence(at path: String) throws -&gt; Persistence { try CoreDataPersistence(path: path) } } #elseif canImport(MyOtherPersistence) // uses Realm private final class PersistenceFactoryImpl: PersistenceFactory { func newPersistence(at path: String) throws -&gt; Persistence { try RealmPersistence(path: path) } } #else // unsupported platform #endif Finally, in the consumer app we would do this regardless of the operating system: func someFunction() { let path = "SomeFile.db" let persistence = Factories.persistence.newPersistence(at: path) // ... do { print("Supports synchronization: \(persistence.supportsSynchronization)") try persistence.save("SomeString") } catch { // ... } } The library would just take care of the different implementations. Bottom line It’s easy to overcome the platform differences with SwiftPM conditionals and simple design patterns. If you need even more customizations, don’t be afraid to tweak the manifest further because it’s good old Swift, not static YAML. Even just an if, or reading environment variables with ProcessInfo, may do wonders and resolve convoluted dynamic package layouts. Yes, in FOOBAR="value" swift build, the FOOBAR variable is reachable from your manifest! In the next article, we’ll start the long but inevitable journey of Swift interoperability with C and other languages.]]></summary></entry><entry><title type="html">A true case for Dependency Injection</title><link href="https://davidederosa.com/2025/05/a-true-case-for-dependency-injection/" rel="alternate" type="text/html" title="A true case for Dependency Injection" /><published>2025-05-24T00:00:00+02:00</published><updated>2025-05-24T00:00:00+02:00</updated><id>https://davidederosa.com/2025/05/a-true-case-for-dependency-injection</id><content type="html" xml:base="https://davidederosa.com/2025/05/a-true-case-for-dependency-injection/"><![CDATA[<p>When studying the foundations of a programming language, for example, during a career in Computer Science, very rarely are <em>design patterns</em> and the concept of <em>software architecture</em> presented in a way that can be transferred to real-world scenarios. Add to that, you may never use most of the well-known patterns, and it’s okay because you don’t want to be a hammer looking for a nail. You shouldn’t force a design pattern for the sake of using it.</p>

<p><a href="#how-di-helps-me-scale-passepartout">Below</a>, I’ll show you how a popular design pattern helped me rework Passepartout for Mac to distribute it <a href="https://github.com/passepartoutvpn/passepartout/issues/231">outside of the App Store</a>, without messing too much with the existing and stable codebase.</p>

<h3 id="experience-produces-patterns">Experience produces patterns</h3>

<p>Patterns are simply an outcome of your programming experience, in that you recognize a common problem for which a common solution also exists. Yet, the amount of buzzwords in the online communities around what some erroneously call “architectures” is ridiculous –the MVVM acronym being the one I stand the least–, to the point that the poor newcomers may feel intimidated. The risk of being ostracized for not using “the right name for the thing” is real, even if the same thing could be named differently the moment you visit a different community.</p>

<p>But hey, listen, the reality is brighter: compilers don’t give a damn about the name you give to your grand architectures. The only names that matter, at the end of the day, are those coming from the syntax of the programming language you use.</p>

<h3 id="popular-design-patterns">Popular design patterns</h3>

<p>Nevertheless, some design patterns are so popular that their names are <em>de facto</em> universal:</p>

<ul>
  <li><a href="https://refactoring.guru/design-patterns/builder">Builder</a></li>
  <li><a href="https://refactoring.guru/design-patterns/command">Command</a></li>
  <li><a href="https://refactoring.guru/design-patterns/factory-method">Factory</a></li>
  <li><a href="https://refactoring.guru/design-patterns/singleton">Singleton</a></li>
  <li><a href="https://refactoring.guru/design-patterns/strategy">Strategy</a></li>
  <li>…</li>
</ul>

<p>You’re bound to cross them at least once in your lifetime. If you like practice more than theory, you definitely used any of the above without the need to give them a name. These patterns are undoubtly useful, they resolve basic architectural problems and, contrary to some beliefs, by no means are they tied to OOP.</p>

<p>Then there is <em>Dependency Injection</em> (DI). I hate giving this one a name, but there it is. More than a design pattern, DI is an <em>approach</em> to making software. I call it that way to avoid the terrible mistake of thinking that there is only one way to do it. I mean, if you’re a Java programmer, you don’t need the <a href="https://spring.io/projects/spring-framework">Spring Framework</a> to do DI.</p>

<p>Here’s how I like to phrase it: <strong>DI is the act of decoupling your software from the underlying implementations of its dependencies.</strong></p>

<h3 id="how-di-helps-me-scale-passepartout">How DI helps me scale Passepartout</h3>

<p>Weeks ago, I decided to make Passepartout for Mac available <a href="https://github.com/passepartoutvpn/passepartout/issues/231">outside of the App Store</a>. Making such a VPN app standalone is no trivial task because the way it operates is radically different: the UI is still a frontend to the VPN backend, but the app and the VPN processes execute as different users, and they do not easily communicate. Specifically, the VPN is deployed as <a href="apple-sysex">System Extension</a>, and therefore runs as <code class="language-plaintext highlighter-rouge">root</code>.</p>

<p>By leaving the App Store, I was about to lose a big chunk of features:</p>

<ul>
  <li>App Groups: required for app/VPN IPC (inter-process communication), data sharing, and logs</li>
  <li>Shared keychain: used to persist the VPN profiles</li>
  <li>In-app purchases</li>
  <li>iCloud</li>
</ul>

<p>In-app purchases and iCloud could be postponed by stripping paid features, but the core functionality of Passepartout relied on both App Groups and the shared keychain. I hit a tough blocker.</p>

<p>Here’s where DI comes to the rescue: <strong>you don’t change the business logic of your software</strong>, you rather change <em>how</em> that logic is implemented deep down in the leaves of the dependency tree. I still wanted to “share data between the app and the VPN process” (business logic), but I needed to change <em>how</em> that data was shared (dependency). Remember, this isolation is only possible if the two concerns are sharply separated, but this is the core principle behind DI.</p>

<p>The core library of Passepartout, <em>Partout,</em> is 100% pure Swift for this reason: the logic of the library is always the same, with the “low-level” implementations abstracted as <code class="language-plaintext highlighter-rouge">protocol</code>s, and for which the app is free to provide (inject) <em>truly</em> different implementations. In my case, it turned out that I could just craft new implementations for the standalone Mac app, whereas anything else would stay untouched.</p>

<h3 id="swap-out-the-broken-pieces">Swap out the broken pieces</h3>

<p>The process is fairly simple:</p>

<ul>
  <li>For each dependency, identify the “broken” implementation of a <code class="language-plaintext highlighter-rouge">protocol</code></li>
  <li>Write a new implementation, compatible with the target</li>
  <li>Unit test behavior as per the <code class="language-plaintext highlighter-rouge">protocol</code> pre/post conditions</li>
  <li>Swap the unsupported implementation with the new one</li>
</ul>

<p>After these steps, passing the tests would imply that the app will work like before, but regardless of being downloaded from the App Store or not. I can’t tell how thrilling it is when you see the magic of programming in action. This is a real-world situation where good practices and constant refactoring pay off.</p>

<p>The new Mac app eventually works around the missing functionalities by dynamically replacing (<code class="language-plaintext highlighter-rouge">supportsAppGroups</code> is false in this case):</p>

<ul>
  <li><a href="https://github.com/passepartoutvpn/partout/blob/master/Sources/Platforms/Apple/UserDefaultsEnvironment.swift"><code class="language-plaintext highlighter-rouge">UserDefaultsEnvironment</code></a> with <a href="https://github.com/passepartoutvpn/partout/blob/master/Sources/Platforms/AppleNE/App/NETunnelEnvironment.swift"><code class="language-plaintext highlighter-rouge">NETunnelEnvironment</code></a>, which does IPC by sending messages to the System Extension, rather than sharing data through the App Group <code class="language-plaintext highlighter-rouge">UserDefaults</code>. They both implement the <code class="language-plaintext highlighter-rouge">TunnelEnvironmentReader</code> protocol, meant for reading VPN data from the app.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">TunnelEnvironmentReader</span><span class="p">:</span> <span class="kt">Sendable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">environmentValue</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">TunnelEnvironmentKey</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Decodable</span>
<span class="p">}</span>
</code></pre></div></div>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpassepartout%2Fblob%2F7ffe37ea0d9e280b7cafbeff1332d431173be2d4%2FPassepartout%2FShared%2FDependencies%252BPartout.swift%23L59-L76&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<ul>
  <li><a href="https://github.com/passepartoutvpn/partout/blob/master/Sources/Platforms/AppleNE/Serialization/KeychainNEProtocolCoder.swift"><code class="language-plaintext highlighter-rouge">KeychainNEProtocolCoder</code></a> with <a href="https://github.com/passepartoutvpn/partout/blob/master/Sources/Platforms/AppleNE/Serialization/ProviderNEProtocolCoder.swift"><code class="language-plaintext highlighter-rouge">ProviderNEProtocolCoder</code></a>, which installs the VPN profiles without the keychain, using the Network Extension map in <code class="language-plaintext highlighter-rouge">providerConfiguration</code>. They both implement the <code class="language-plaintext highlighter-rouge">NEProtocolCoder</code> protocol, meant for VPN profiles serialization.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">NEProtocolCoder</span><span class="p">:</span> <span class="kt">Sendable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">protocolConfiguration</span><span class="p">(</span><span class="n">from</span> <span class="nv">profile</span><span class="p">:</span> <span class="kt">Profile</span><span class="p">,</span> <span class="nv">title</span><span class="p">:</span> <span class="p">(</span><span class="kt">Profile</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">NETunnelProviderProtocol</span>

    <span class="kd">func</span> <span class="nf">profile</span><span class="p">(</span><span class="n">from</span> <span class="nv">protocolConfiguration</span><span class="p">:</span> <span class="kt">NETunnelProviderProtocol</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Profile</span>
<span class="p">}</span>
</code></pre></div></div>

<script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fpassepartoutvpn%2Fpassepartout%2Fblob%2F7ffe37ea0d9e280b7cafbeff1332d431173be2d4%2FPassepartout%2FShared%2FDependencies%252BPartout.swift%23L40-L57&amp;style=default&amp;type=code&amp;showBorder=on&amp;showLineNumbers=on&amp;showFileMeta=on&amp;showFullPath=on&amp;showCopy=on"></script>

<h3 id="do-you-really-need-di">Do you really need DI?</h3>

<p>You’d better follow the DI approach early in your software development, but not immediately, because you may never need to convert a code module into a pluggable dependency. If you foresee that your software will scale enough to justify such an abstraction, then start pulling out third parties from your concrete classes.</p>

<p>By the way, in many corporate projects people use DI because “everybody does”, rather than understanding the real benefits and tradeoffs. The overhead of maintaining abstract layers, or even third parties, for entities that will <em>always</em> have one implementation is sadly laughable. Please, do not avoid concrete classes just because you read that on some book. As I said in the beginning, you shouldn’t use a solution for a problem you don’t have, and most projects don’t need bulky external third parties to deal with their trivial dependencies. If you wasted hours to track down the order and lifecycle of the objects that an app creates on launch, you know what I’m talking about.</p>

<p>Sometimes, it really seems that some modern programmers don’t know how to initialize objects in the first place. In that case, rather than a dependency injection engine –whatever that means–, why not go back to the basics?</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="dependency injection" /><summary type="html"><![CDATA[When studying the foundations of a programming language, for example, during a career in Computer Science, very rarely are design patterns and the concept of software architecture presented in a way that can be transferred to real-world scenarios. Add to that, you may never use most of the well-known patterns, and it’s okay because you don’t want to be a hammer looking for a nail. You shouldn’t force a design pattern for the sake of using it. Below, I’ll show you how a popular design pattern helped me rework Passepartout for Mac to distribute it outside of the App Store, without messing too much with the existing and stable codebase. Experience produces patterns Patterns are simply an outcome of your programming experience, in that you recognize a common problem for which a common solution also exists. Yet, the amount of buzzwords in the online communities around what some erroneously call “architectures” is ridiculous –the MVVM acronym being the one I stand the least–, to the point that the poor newcomers may feel intimidated. The risk of being ostracized for not using “the right name for the thing” is real, even if the same thing could be named differently the moment you visit a different community. But hey, listen, the reality is brighter: compilers don’t give a damn about the name you give to your grand architectures. The only names that matter, at the end of the day, are those coming from the syntax of the programming language you use. Popular design patterns Nevertheless, some design patterns are so popular that their names are de facto universal: Builder Command Factory Singleton Strategy … You’re bound to cross them at least once in your lifetime. If you like practice more than theory, you definitely used any of the above without the need to give them a name. These patterns are undoubtly useful, they resolve basic architectural problems and, contrary to some beliefs, by no means are they tied to OOP. Then there is Dependency Injection (DI). I hate giving this one a name, but there it is. More than a design pattern, DI is an approach to making software. I call it that way to avoid the terrible mistake of thinking that there is only one way to do it. I mean, if you’re a Java programmer, you don’t need the Spring Framework to do DI. Here’s how I like to phrase it: DI is the act of decoupling your software from the underlying implementations of its dependencies. How DI helps me scale Passepartout Weeks ago, I decided to make Passepartout for Mac available outside of the App Store. Making such a VPN app standalone is no trivial task because the way it operates is radically different: the UI is still a frontend to the VPN backend, but the app and the VPN processes execute as different users, and they do not easily communicate. Specifically, the VPN is deployed as System Extension, and therefore runs as root. By leaving the App Store, I was about to lose a big chunk of features: App Groups: required for app/VPN IPC (inter-process communication), data sharing, and logs Shared keychain: used to persist the VPN profiles In-app purchases iCloud In-app purchases and iCloud could be postponed by stripping paid features, but the core functionality of Passepartout relied on both App Groups and the shared keychain. I hit a tough blocker. Here’s where DI comes to the rescue: you don’t change the business logic of your software, you rather change how that logic is implemented deep down in the leaves of the dependency tree. I still wanted to “share data between the app and the VPN process” (business logic), but I needed to change how that data was shared (dependency). Remember, this isolation is only possible if the two concerns are sharply separated, but this is the core principle behind DI. The core library of Passepartout, Partout, is 100% pure Swift for this reason: the logic of the library is always the same, with the “low-level” implementations abstracted as protocols, and for which the app is free to provide (inject) truly different implementations. In my case, it turned out that I could just craft new implementations for the standalone Mac app, whereas anything else would stay untouched. Swap out the broken pieces The process is fairly simple: For each dependency, identify the “broken” implementation of a protocol Write a new implementation, compatible with the target Unit test behavior as per the protocol pre/post conditions Swap the unsupported implementation with the new one After these steps, passing the tests would imply that the app will work like before, but regardless of being downloaded from the App Store or not. I can’t tell how thrilling it is when you see the magic of programming in action. This is a real-world situation where good practices and constant refactoring pay off. The new Mac app eventually works around the missing functionalities by dynamically replacing (supportsAppGroups is false in this case): UserDefaultsEnvironment with NETunnelEnvironment, which does IPC by sending messages to the System Extension, rather than sharing data through the App Group UserDefaults. They both implement the TunnelEnvironmentReader protocol, meant for reading VPN data from the app. public protocol TunnelEnvironmentReader: Sendable { func environmentValue&lt;T&gt;(forKey key: TunnelEnvironmentKey&lt;T&gt;) -&gt; T? where T: Decodable } KeychainNEProtocolCoder with ProviderNEProtocolCoder, which installs the VPN profiles without the keychain, using the Network Extension map in providerConfiguration. They both implement the NEProtocolCoder protocol, meant for VPN profiles serialization. public protocol NEProtocolCoder: Sendable { func protocolConfiguration(from profile: Profile, title: (Profile) -&gt; String) throws -&gt; NETunnelProviderProtocol func profile(from protocolConfiguration: NETunnelProviderProtocol) throws -&gt; Profile } Do you really need DI? You’d better follow the DI approach early in your software development, but not immediately, because you may never need to convert a code module into a pluggable dependency. If you foresee that your software will scale enough to justify such an abstraction, then start pulling out third parties from your concrete classes. By the way, in many corporate projects people use DI because “everybody does”, rather than understanding the real benefits and tradeoffs. The overhead of maintaining abstract layers, or even third parties, for entities that will always have one implementation is sadly laughable. Please, do not avoid concrete classes just because you read that on some book. As I said in the beginning, you shouldn’t use a solution for a problem you don’t have, and most projects don’t need bulky external third parties to deal with their trivial dependencies. If you wasted hours to track down the order and lifecycle of the objects that an app creates on launch, you know what I’m talking about. Sometimes, it really seems that some modern programmers don’t know how to initialize objects in the first place. In that case, rather than a dependency injection engine –whatever that means–, why not go back to the basics?]]></summary></entry><entry><title type="html">Cross-platform Swift: Core libraries</title><link href="https://davidederosa.com/cross-platform-swift/core-libraries/" rel="alternate" type="text/html" title="Cross-platform Swift: Core libraries" /><published>2025-05-05T00:00:00+02:00</published><updated>2025-05-05T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-core-libraries</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/core-libraries/"><![CDATA[<p>When programming Swift in Xcode, we take for granted a few things that are in fact different when you compile on other platforms. Here I show you those I stumbled upon, and how I worked around some limitations of the bare Swift toolchain.</p>

<h2 id="foundation">Foundation</h2>

<p>Have you ever compiled Swift code without importing <a href="https://developer.apple.com/documentation/foundation/"><code class="language-plaintext highlighter-rouge">Foundation</code></a>? Do you even think it’s possible? Look at the most basic Swift template in Xcode:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  File.swift</span>
<span class="c1">//  Passepartout</span>
<span class="c1">//</span>
<span class="c1">//  Created by Davide De Rosa on 5/5/25.</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="kt">Foundation</span>
</code></pre></div></div>

<p>which in Objective-C would be:</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  File.m</span>
<span class="c1">//  Passepartout</span>
<span class="c1">//</span>
<span class="c1">//  Created by Davide De Rosa on 5/5/25.</span>
<span class="c1">//</span>

<span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span></code></pre></div></div>

<p>Let’s cut it short to the bad news: <strong><code class="language-plaintext highlighter-rouge">Foundation</code> is not part of the Swift language</strong>.</p>

<p><code class="language-plaintext highlighter-rouge">Foundation</code> is, however, available as an import in the prebuilt Swift toolchains for non-Apple platforms. Why is that? Over the years, those pseudo-implicit imports may have convinced most of us that <code class="language-plaintext highlighter-rouge">Foundation</code> has always been a standard library. First, as an Objective-C wrapper of <a href="https://developer.apple.com/documentation/corefoundation/"><code class="language-plaintext highlighter-rouge">CoreFoundation</code></a>. Later, as an integral part of Swift.</p>

<p>The maintainers of the otherwise modern Apple language are well aware of this heavy legacy, so they created a replacement for <code class="language-plaintext highlighter-rouge">Foundation</code> that is not bound to the Apple SDK. Beware that if you build the Swift toolchain by yourself, <code class="language-plaintext highlighter-rouge">Foundation</code> is not included by default. This tells me that maybe, <em>maybe</em>, <code class="language-plaintext highlighter-rouge">Foundation</code> will also depart from Swift someday. You were warned.</p>

<p>Below are a few <code class="language-plaintext highlighter-rouge">Foundation</code> entities that many developers are familiar with:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Data</code> for binary data (bridging ObjC <code class="language-plaintext highlighter-rouge">NSData</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">Date</code> for dates and timestamps (briding ObjC <code class="language-plaintext highlighter-rouge">NSDate</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">UUID</code> for unique identifiers</li>
  <li><code class="language-plaintext highlighter-rouge">JSONEncoder</code> and <code class="language-plaintext highlighter-rouge">JSONDecoder</code> (these are pure Swift)</li>
  <li><code class="language-plaintext highlighter-rouge">URL</code>, <code class="language-plaintext highlighter-rouge">URLSession</code> and tasks (bridigng ObjC <code class="language-plaintext highlighter-rouge">NSURL</code> and <code class="language-plaintext highlighter-rouge">NSURLSession</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">FileManager</code></li>
  <li>A bunch of other <code class="language-plaintext highlighter-rouge">NS</code>-prefixed stuff</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">Foundation</code> import is not as a comprehensive as on Apple. This new version has opt-in modules due to the dependencies that they imply:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FoundationNetworking</code> for <code class="language-plaintext highlighter-rouge">URL</code> and <code class="language-plaintext highlighter-rouge">URLSession</code>, due to the dependency on <code class="language-plaintext highlighter-rouge">libcurl</code></li>
  <li><code class="language-plaintext highlighter-rouge">FoundationXML</code> for <code class="language-plaintext highlighter-rouge">XMLParser</code>, due to the dependency on <code class="language-plaintext highlighter-rouge">libxml2</code></li>
</ul>

<p>Can you get rid of all this stuff already? I doubt you can, unless you started a new project knowing these gotchas beforehand. In my case, I need to keep the burden of this non-standard library, at least until Swift will have a richer standard library.</p>

<p>Last but not least, <code class="language-plaintext highlighter-rouge">Foundation</code> comes with the <a href="https://developer.apple.com/documentation/dispatch">Grand Central Dispatch</a> API, but listen to me: it’s time you learn <a href="https://developer.apple.com/documentation/swift/concurrency"><code class="language-plaintext highlighter-rouge">Concurrency</code></a>.</p>

<h2 id="swift-standard-library">Swift standard library</h2>

<p>You heard that, Swift has a <a href="https://developer.apple.com/documentation/swift/swift-standard-library"><em>standard library</em></a>, but few would be able to delineate its boundaries. The Apple documentation certainly doesn’t help when figuring out what comes from the language, and what comes from <code class="language-plaintext highlighter-rouge">Foundation</code>.</p>

<p>A partial list:</p>

<ul>
  <li>Primitive types: <code class="language-plaintext highlighter-rouge">Bool</code>, <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">Double</code>, …, but <em>not</em> <code class="language-plaintext highlighter-rouge">Data</code> or <code class="language-plaintext highlighter-rouge">Date</code>!</li>
  <li>Protocols: <code class="language-plaintext highlighter-rouge">Comparable</code>, <code class="language-plaintext highlighter-rouge">Equatable</code>, <code class="language-plaintext highlighter-rouge">Hashable</code>, <code class="language-plaintext highlighter-rouge">Identifiable</code>, <code class="language-plaintext highlighter-rouge">Codable</code>, …</li>
  <li>Collections: <code class="language-plaintext highlighter-rouge">Array</code>, <code class="language-plaintext highlighter-rouge">Dictionary</code>, <code class="language-plaintext highlighter-rouge">Set</code>, <code class="language-plaintext highlighter-rouge">Collection</code>, …</li>
  <li>Flow constructs: <code class="language-plaintext highlighter-rouge">Result</code>, <code class="language-plaintext highlighter-rouge">Error</code></li>
  <li>String description protocols: <code class="language-plaintext highlighter-rouge">CustomStringConvertible</code> and variations</li>
</ul>

<p>Thank God, <code class="language-plaintext highlighter-rouge">Concurrency</code> is also part of the library.</p>

<h2 id="platform-specific-packages">Platform-specific packages</h2>

<p>When developing on macOS, you may notice that standard C functions are implicitly bridged to Swift code. This autocompletion is proof:</p>

<p><img src="/s/f/cross-platform-swift/core-libraries-xcode-c-autocompletion.png" alt="C autocompletion of memcpy in Xcode" /></p>

<p>The other Swift environments behave differently, and honestly, I prefer it that way. I’d rather import things explicitly when needed. Therefore, the compiler will stop at C symbols in Swift code out of the box. Windows in particular doesn’t follow the POSIX naming, and some symbols come from very differently named headers. For example, the first symbol that triggered a compiler failure for me was <code class="language-plaintext highlighter-rouge">AF_INET</code>, which on Windows is part of <code class="language-plaintext highlighter-rouge">WinSock2.h</code>.</p>

<p>While the header names are relevant in C code, Swift remains a bit more agnostic by hiding them behind platform-specific packages:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">import WinSDK</code> on Windows</li>
  <li><code class="language-plaintext highlighter-rouge">import Linux</code> on Linux</li>
  <li><code class="language-plaintext highlighter-rouge">import Android</code> on Android</li>
</ul>

<p>The imports still require some <code class="language-plaintext highlighter-rouge">#if</code> conditionals here and there. At that point, you may run into a few C symbols that are only available on Apple platforms, like any variation of <code class="language-plaintext highlighter-rouge">NSEC_PER_*</code> in my library. In that case, you can redefine those symbols yourself, or refactor the code to not use them at all.</p>

<p>Another thing I noticed is name clashes. To name one, Windows seems to have a name clash on <code class="language-plaintext highlighter-rouge">UUID</code> (alias for <code class="language-plaintext highlighter-rouge">GUID</code> in Win32), which I resolved this way:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if os(Windows)</span>
<span class="kd">import</span> <span class="kt">WinSDK</span>
<span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">UUID</span> <span class="o">=</span> <span class="kt">Foundation</span><span class="o">.</span><span class="kt">UUID</span>
<span class="cp">#endif</span>
</code></pre></div></div>

<p>There might be more similar occurrences, but you can get around them with conditionals and forced <code class="language-plaintext highlighter-rouge">typealias</code>. If you know better ways, please leave a comment below the post.</p>

<h2 id="objective-c-runtime">Objective-C runtime</h2>

<p>The need for the Objective-C runtime in your Swift code may be incredibly subtle. Look at a linker error I faced:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lld-link: error: undefined symbol: objc_autoreleaseReturnValue
</code></pre></div></div>

<p>I was lucky to catch the issue in a place where the compiler could not provide any hint. The culprit was a class of the Partout API that was using the <a href="https://developer.apple.com/documentation/javascriptcore"><code class="language-plaintext highlighter-rouge">JavaScriptCore</code></a> framework, which in turn required Swift closures to be Objective-C blocks to inject custom functions into the JavaScript code. If you’ve never seen that, here’s a bit of the offending code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">inject</span><span class="p">(</span><span class="s">"getText"</span><span class="p">,</span> <span class="nv">object</span><span class="p">:</span> <span class="n">vm</span><span class="o">.</span><span class="n">getText</span> <span class="k">as</span> <span class="kd">@convention</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">(</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Any</span><span class="p">?)</span>
</code></pre></div></div>

<p>Frankly, I wondered why the code compiled at all, so I tried to put <code class="language-plaintext highlighter-rouge">@objc</code> on top of a Swift class on Linux:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>File.swift:1:2: error: Objective-C interoperability is disabled
</code></pre></div></div>

<p>Gosh, then why does <code class="language-plaintext highlighter-rouge">@convention(block)</code> compile on non-Apple, if the linker is always bound to fail? I have no idea, but look at your code carefully if it compiles fine but the linker complains about some Objective-C runtime or obscure <code class="language-plaintext highlighter-rouge">NS*</code> entity.</p>

<p>Fun fact: <code class="language-plaintext highlighter-rouge">JavaScriptCore</code> is an Objective-C framework with iOS 16 as the <em>minimum target</em>, which deceived me into seeing it as a “new thing”.</p>

<h2 id="bottom-line">Bottom line</h2>

<p>Stick with pure Swift as much as you can, and when you use <code class="language-plaintext highlighter-rouge">Foundation</code>, do it with a grain of salt: the Swift standard library is much smaller than you think. Spot any Objective-C sorcery, and kill it for good.</p>

<p>In the next article, I will show you how conditionals and dependency injection allows us to still use frameworks that are not available on all platforms.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><category term="c" /><summary type="html"><![CDATA[When programming Swift in Xcode, we take for granted a few things that are in fact different when you compile on other platforms. Here I show you those I stumbled upon, and how I worked around some limitations of the bare Swift toolchain. Foundation Have you ever compiled Swift code without importing Foundation? Do you even think it’s possible? Look at the most basic Swift template in Xcode: // // File.swift // Passepartout // // Created by Davide De Rosa on 5/5/25. // import Foundation which in Objective-C would be: // // File.m // Passepartout // // Created by Davide De Rosa on 5/5/25. // #import &lt;Foundation/Foundation.h&gt; Let’s cut it short to the bad news: Foundation is not part of the Swift language. Foundation is, however, available as an import in the prebuilt Swift toolchains for non-Apple platforms. Why is that? Over the years, those pseudo-implicit imports may have convinced most of us that Foundation has always been a standard library. First, as an Objective-C wrapper of CoreFoundation. Later, as an integral part of Swift. The maintainers of the otherwise modern Apple language are well aware of this heavy legacy, so they created a replacement for Foundation that is not bound to the Apple SDK. Beware that if you build the Swift toolchain by yourself, Foundation is not included by default. This tells me that maybe, maybe, Foundation will also depart from Swift someday. You were warned. Below are a few Foundation entities that many developers are familiar with: Data for binary data (bridging ObjC NSData) Date for dates and timestamps (briding ObjC NSDate) UUID for unique identifiers JSONEncoder and JSONDecoder (these are pure Swift) URL, URLSession and tasks (bridigng ObjC NSURL and NSURLSession) FileManager A bunch of other NS-prefixed stuff The Foundation import is not as a comprehensive as on Apple. This new version has opt-in modules due to the dependencies that they imply: FoundationNetworking for URL and URLSession, due to the dependency on libcurl FoundationXML for XMLParser, due to the dependency on libxml2 Can you get rid of all this stuff already? I doubt you can, unless you started a new project knowing these gotchas beforehand. In my case, I need to keep the burden of this non-standard library, at least until Swift will have a richer standard library. Last but not least, Foundation comes with the Grand Central Dispatch API, but listen to me: it’s time you learn Concurrency. Swift standard library You heard that, Swift has a standard library, but few would be able to delineate its boundaries. The Apple documentation certainly doesn’t help when figuring out what comes from the language, and what comes from Foundation. A partial list: Primitive types: Bool, Int, String, Double, …, but not Data or Date! Protocols: Comparable, Equatable, Hashable, Identifiable, Codable, … Collections: Array, Dictionary, Set, Collection, … Flow constructs: Result, Error String description protocols: CustomStringConvertible and variations Thank God, Concurrency is also part of the library. Platform-specific packages When developing on macOS, you may notice that standard C functions are implicitly bridged to Swift code. This autocompletion is proof: The other Swift environments behave differently, and honestly, I prefer it that way. I’d rather import things explicitly when needed. Therefore, the compiler will stop at C symbols in Swift code out of the box. Windows in particular doesn’t follow the POSIX naming, and some symbols come from very differently named headers. For example, the first symbol that triggered a compiler failure for me was AF_INET, which on Windows is part of WinSock2.h. While the header names are relevant in C code, Swift remains a bit more agnostic by hiding them behind platform-specific packages: import WinSDK on Windows import Linux on Linux import Android on Android The imports still require some #if conditionals here and there. At that point, you may run into a few C symbols that are only available on Apple platforms, like any variation of NSEC_PER_* in my library. In that case, you can redefine those symbols yourself, or refactor the code to not use them at all. Another thing I noticed is name clashes. To name one, Windows seems to have a name clash on UUID (alias for GUID in Win32), which I resolved this way: #if os(Windows) import WinSDK public typealias UUID = Foundation.UUID #endif There might be more similar occurrences, but you can get around them with conditionals and forced typealias. If you know better ways, please leave a comment below the post. Objective-C runtime The need for the Objective-C runtime in your Swift code may be incredibly subtle. Look at a linker error I faced: lld-link: error: undefined symbol: objc_autoreleaseReturnValue I was lucky to catch the issue in a place where the compiler could not provide any hint. The culprit was a class of the Partout API that was using the JavaScriptCore framework, which in turn required Swift closures to be Objective-C blocks to inject custom functions into the JavaScript code. If you’ve never seen that, here’s a bit of the offending code: inject("getText", object: vm.getText as @convention(block) (String) -&gt; Any?) Frankly, I wondered why the code compiled at all, so I tried to put @objc on top of a Swift class on Linux: File.swift:1:2: error: Objective-C interoperability is disabled Gosh, then why does @convention(block) compile on non-Apple, if the linker is always bound to fail? I have no idea, but look at your code carefully if it compiles fine but the linker complains about some Objective-C runtime or obscure NS* entity. Fun fact: JavaScriptCore is an Objective-C framework with iOS 16 as the minimum target, which deceived me into seeing it as a “new thing”. Bottom line Stick with pure Swift as much as you can, and when you use Foundation, do it with a grain of salt: the Swift standard library is much smaller than you think. Spot any Objective-C sorcery, and kill it for good. In the next article, I will show you how conditionals and dependency injection allows us to still use frameworks that are not available on all platforms.]]></summary></entry><entry><title type="html">Scripting and open-source adoption</title><link href="https://davidederosa.com/2025/04/scripting-and-open-source-adoption/" rel="alternate" type="text/html" title="Scripting and open-source adoption" /><published>2025-04-24T00:00:00+02:00</published><updated>2025-04-24T00:00:00+02:00</updated><id>https://davidederosa.com/2025/04/scripting-and-open-source-adoption</id><content type="html" xml:base="https://davidederosa.com/2025/04/scripting-and-open-source-adoption/"><![CDATA[<p>Recently, I stumbled upon an <a href="https://www.youtube.com/watch?v=p0Q3oDY9A5s">old video by ThePrimeagen</a> where he claimed he’d quit using Vim for good after its major update.</p>

<p>For those who don’t know, <a href="https://www.vim.org/">Vim</a> is a <em>ubiquitous</em> text editor, especially popular among avid terminal-oriented users. It is a legendary software, but it has a steep learning curve, to the point that “quitting Vim” <a href="https://stackoverflow.com/questions/11828270/how-do-i-exit-vim">has become a meme</a> for being notoriously unintuitive.</p>

<p><a href="https://twitch.tv/theprimeagen">ThePrimeagen</a> is a prominent Twitch streamer, and a staunch advocate of <a href="https://neovim.io/">Neovim</a>, a fork of the original Vim editor. In his video, he makes a solid point about the stubbornness of Vim maintainers to stick with a custom scripting language. On the other hand, Neovim, promotes the well-known <a href="https://www.lua.org/">Lua</a> language for its powerful plugin system. This alone determined his final choice to stick with Neovim, and as of 2025, I doubt he has changed his mind.</p>

<h3 id="the-delusion-behind-open-source">The delusion behind open-source</h3>

<p>This story is somewhat related to what I’m trying now that I work full-time on <a href="https://passepartoutvpn.app">Passepartout</a>. Passepartout is an open-source project in that its code is public, but there are almost no code contributions, just issues. There are good reasons behind this.</p>

<p>Many of those who improvise some sort of open-source software think that it must be interesting by default, just because it’s open and available for free. Rarely will they realize that <em>popular</em> free software is not popular <em>only for being free</em>, so they live in the delusion that the open-source model “doesn’t work”.</p>

<p>For example, pick any GNU tool (grep, sed, make, …) or even Linux. They became popular because they were <em>useful</em>. Being free and <em>understandable</em> software made them thrive through public contributions, but this was never the first step.</p>

<p>The interest in contributing to an open-source project is determined by multiple factors, in order of importance:</p>

<ol>
  <li>Goals</li>
  <li>Well-written documentation and directions</li>
  <li>Welcoming community</li>
  <li>Technical stack</li>
  <li>Stable software architecture</li>
</ol>

<p>Now, observe how any well-known free software meets 1-5 in that order.</p>

<h3 id="vim-and-the-self-conscious-tech">Vim and the self-conscious tech</h3>

<p>Given that both Vim and Neovim are amazing and well-documented products, their tech paths reconnect with the initial backstory.</p>

<p>Lua makes Neovim <em>infinitely</em> more attractive than Vim when it comes to adoption and open-source, and the choice of Vimscript over Lua may even determine the death of Vim in the long run. I don’t know the “drama” that resulted in the fork of Neovim, but I wouldn’t exclude that Vim took its relevance for granted just for being the OG of the two. In fact, I don’t think that Vim today can claim being cooler than Neovim other than for being the original one.</p>

<p>Even if a software is well-crafted, it’s evident that a Pascal application will only attract a handful of developers, whereas JavaScript would open up to the entire globe, and the same applies to Vimscript versus Lua. If your software is written for yourself and requires developers to learn a new technology to contribute, either it is the most remarkable piece of art in software history, or you might well end up yelling at your echo chamber.</p>

<h3 id="a-new-javascript-api-in-passepartout">A new JavaScript API in Passepartout</h3>

<p>The Vim story taught me that I needed to make my project more accessible to the potential contributors, otherwise it will never be more than a one-man team.</p>

<p>While I invest a lot in making the software architecture as modular as I can, I haven’t spent as much time in documenting <em>how</em> to start contributing to the codebase. I know myself how intimidating it is to submit a PR to someone else’s repository, so it’s crucial that we, the maintainers, provide a viable entry point to those willing to collaborate. A welcoming, non-judging community also reduces the friction of the first public contribution.</p>

<p>One part that I’ve always found potentially accessible was the Providers API, which is how Passepartout auto-compiles VPN configurations for a plethora of provider servers. Nevertheless, no one ever contributed a single provider, and no wonder: providers were generated in CI with a convoluted set of undocumented Ruby scripts. Who on Earth would want to touch that mess?</p>

<p>When I found out about <a href="https://developer.apple.com/documentation/javascriptcore">JavaScriptCore</a> to solve a different problem, I suddenly realized how scripting could be a lower barrier to enter the Passepartout codebase, as there are way more JavaScript than Swift developers out there.</p>

<p>With the help of AI, I rapidly converted the old Ruby legacy to a brand new <a href="https://github.com/passepartoutvpn/api-source">Node.js implementation</a> that most developers would find easy to understand, develop, and test without even installing the app. Then I started documenting <a href="https://github.com/passepartoutvpn/api-source?tab=readme-ov-file#new-providers">how to submit a provider</a> step by step. This doesn’t imply that people will start adding new providers today, but offering accessible tools and documentation is a <em>strict</em> requirement for that to happen.</p>

<h3 id="conclusions">Conclusions</h3>

<p>Open-source success isn’t about being free, it’s about being accessible. Tools like Neovim thrive because they choose approachable technologies like Lua, making contributions easier. Similarly, by adopting JavaScript for scripting, Passepartout lowers its barrier to entry and opens the door to wider community involvement. If you want contributors, you must meet them where they are.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="lua" /><category term="javascript" /><category term="vim" /><category term="neovim" /><category term="open-source" /><summary type="html"><![CDATA[Recently, I stumbled upon an old video by ThePrimeagen where he claimed he’d quit using Vim for good after its major update. For those who don’t know, Vim is a ubiquitous text editor, especially popular among avid terminal-oriented users. It is a legendary software, but it has a steep learning curve, to the point that “quitting Vim” has become a meme for being notoriously unintuitive. ThePrimeagen is a prominent Twitch streamer, and a staunch advocate of Neovim, a fork of the original Vim editor. In his video, he makes a solid point about the stubbornness of Vim maintainers to stick with a custom scripting language. On the other hand, Neovim, promotes the well-known Lua language for its powerful plugin system. This alone determined his final choice to stick with Neovim, and as of 2025, I doubt he has changed his mind. The delusion behind open-source This story is somewhat related to what I’m trying now that I work full-time on Passepartout. Passepartout is an open-source project in that its code is public, but there are almost no code contributions, just issues. There are good reasons behind this. Many of those who improvise some sort of open-source software think that it must be interesting by default, just because it’s open and available for free. Rarely will they realize that popular free software is not popular only for being free, so they live in the delusion that the open-source model “doesn’t work”. For example, pick any GNU tool (grep, sed, make, …) or even Linux. They became popular because they were useful. Being free and understandable software made them thrive through public contributions, but this was never the first step. The interest in contributing to an open-source project is determined by multiple factors, in order of importance: Goals Well-written documentation and directions Welcoming community Technical stack Stable software architecture Now, observe how any well-known free software meets 1-5 in that order. Vim and the self-conscious tech Given that both Vim and Neovim are amazing and well-documented products, their tech paths reconnect with the initial backstory. Lua makes Neovim infinitely more attractive than Vim when it comes to adoption and open-source, and the choice of Vimscript over Lua may even determine the death of Vim in the long run. I don’t know the “drama” that resulted in the fork of Neovim, but I wouldn’t exclude that Vim took its relevance for granted just for being the OG of the two. In fact, I don’t think that Vim today can claim being cooler than Neovim other than for being the original one. Even if a software is well-crafted, it’s evident that a Pascal application will only attract a handful of developers, whereas JavaScript would open up to the entire globe, and the same applies to Vimscript versus Lua. If your software is written for yourself and requires developers to learn a new technology to contribute, either it is the most remarkable piece of art in software history, or you might well end up yelling at your echo chamber. A new JavaScript API in Passepartout The Vim story taught me that I needed to make my project more accessible to the potential contributors, otherwise it will never be more than a one-man team. While I invest a lot in making the software architecture as modular as I can, I haven’t spent as much time in documenting how to start contributing to the codebase. I know myself how intimidating it is to submit a PR to someone else’s repository, so it’s crucial that we, the maintainers, provide a viable entry point to those willing to collaborate. A welcoming, non-judging community also reduces the friction of the first public contribution. One part that I’ve always found potentially accessible was the Providers API, which is how Passepartout auto-compiles VPN configurations for a plethora of provider servers. Nevertheless, no one ever contributed a single provider, and no wonder: providers were generated in CI with a convoluted set of undocumented Ruby scripts. Who on Earth would want to touch that mess? When I found out about JavaScriptCore to solve a different problem, I suddenly realized how scripting could be a lower barrier to enter the Passepartout codebase, as there are way more JavaScript than Swift developers out there. With the help of AI, I rapidly converted the old Ruby legacy to a brand new Node.js implementation that most developers would find easy to understand, develop, and test without even installing the app. Then I started documenting how to submit a provider step by step. This doesn’t imply that people will start adding new providers today, but offering accessible tools and documentation is a strict requirement for that to happen. Conclusions Open-source success isn’t about being free, it’s about being accessible. Tools like Neovim thrive because they choose approachable technologies like Lua, making contributions easier. Similarly, by adopting JavaScript for scripting, Passepartout lowers its barrier to entry and opens the door to wider community involvement. If you want contributors, you must meet them where they are.]]></summary></entry><entry><title type="html">Cross-platform Swift: Combine</title><link href="https://davidederosa.com/cross-platform-swift/combine/" rel="alternate" type="text/html" title="Cross-platform Swift: Combine" /><published>2025-04-23T00:00:00+02:00</published><updated>2025-04-23T00:00:00+02:00</updated><id>https://davidederosa.com/cross-platform-swift/cross-platform-swift-combine</id><content type="html" xml:base="https://davidederosa.com/cross-platform-swift/combine/"><![CDATA[<p>The very first goal of porting may sound simple: a successful build. Once you manage to just compile your package, the worst is definitely behind you.</p>

<p>Keep in mind that this is not a series about how to port Apple frameworks or SwiftUI to other platforms, it’s about the bare Swift language. I want to show you how Xcode may trick you into thinking that some patterns are a key part of Swift, whereas they should be avoided if you plan to leave the Apple ecosystem at some point.</p>

<p>Today, I’ll talk about a kind of infamous framework for Swift developers: <em>Combine</em>.</p>

<h2 id="combine-is-unofficially-obsolete">Combine is unofficially obsolete</h2>

<p>When the compiler suddenly stopped at some occurrence of <code class="language-plaintext highlighter-rouge">import Combine</code>, I was beaten. Combine has been a fundamental piece of reactive programming for the last 5+ years, and any recent Swift codebase uses Combine to some extent. The scary question was: to what extent was I using it?</p>

<p>Let me digress a moment. There is a big problem with Combine, and it’s not about the developers using it. Apple is well-known for disrupting its own frameworks regardless of any backward-compatibility, and Combine is one of those examples where Apple took a different turn without offering a full replacement. Initially, it seemed that SwiftUI was all about Combine, but the introduction of Concurrency made the poor framework an outcast. Unsurprisingly, <code class="language-plaintext highlighter-rouge">ObservableObject</code> and <code class="language-plaintext highlighter-rouge">@Published</code> are also unavailable outside Apple Swift, but if you’ve been a diligent programmer, you’ve probably learned that those constructs only make sense with SwiftUI.</p>

<p>The fact that Combine has never been integrated into the Swift language, reveals that Concurrency is how Swift (and Apple) wants you to perform asynchronous programming from now on. Does Swift natively offer a substitute for the long list of Combine operators? Hell, no, and that’s why people still use Combine.</p>

<p>Back to my question. Luckily, my use of Combine in Partout was quite basic, except for one <code class="language-plaintext highlighter-rouge">.combineLatest3()</code> that was worth half the effort.</p>

<h2 id="porting-to-asyncsequence">Porting to AsyncSequence</h2>

<p>If you remember, the purpose of Combine is manipulating a sequence of asynchronous values. Swift offers implementations of <a href="https://developer.apple.com/documentation/swift/asyncsequence"><code class="language-plaintext highlighter-rouge">AsyncSequence</code></a> like <a href="https://developer.apple.com/documentation/swift/asyncstream"><code class="language-plaintext highlighter-rouge">AsyncStream</code></a> and <a href="https://developer.apple.com/documentation/swift/asyncthrowingstream"><code class="language-plaintext highlighter-rouge">AsyncThrowingStream</code></a> to accomplish the same in a linear fashion, typical of the async/await model.</p>

<p>What in Combine was:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subscription</span> <span class="o">=</span> <span class="nf">somePublisherOfStrings</span><span class="p">()</span> <span class="c1">// AnyPublisher&lt;String, Never&gt;</span>
    <span class="o">.</span><span class="nf">removeDuplicates</span><span class="p">()</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"String: </span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>becomes this with <code class="language-plaintext highlighter-rouge">AsyncStream</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subscription</span> <span class="o">=</span> <span class="kt">Task</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span>
    <span class="k">var</span> <span class="nv">previous</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">for</span> <span class="k">await</span> <span class="n">string</span> <span class="k">in</span> <span class="nf">someStreamOfStrings</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// AsyncStream&lt;String&gt;</span>
        <span class="k">guard</span> <span class="n">string</span> <span class="o">!=</span> <span class="n">previous</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"String: </span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">string</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, a typical way to spawn Combine publishers is with <em>subjects</em> (<code class="language-plaintext highlighter-rouge">PassthroughSubject</code> and <code class="language-plaintext highlighter-rouge">CurrentValueSubject</code>), that are multicast emitters of values. Multiple programs can subscribe to a subject, listen to its sequence of values, and manipulate them before delivery with the rich offer of Combine operators. We lack such a counterpart in Swift, so I went to <a href="https://github.com/keeshux/subject-streams">roll out my own</a>.</p>

<p>My <a href="https://github.com/keeshux/subject-streams/blob/master/Sources/SubjectStreams/PassthroughStream.swift"><code class="language-plaintext highlighter-rouge">PassthroughStream</code></a> and <a href="https://github.com/keeshux/subject-streams/blob/master/Sources/SubjectStreams/CurrentValueStream.swift"><code class="language-plaintext highlighter-rouge">CurrentValueStream</code></a> implement a simple pub/sub pattern with <code class="language-plaintext highlighter-rouge">AsyncStream</code> and strict Swift 6.1 Concurrency. They have become the building blocks of all my asynchronous publishers in cross-platform Swift, and by keeping behavior and naming close to Combine (e.g. the <code class="language-plaintext highlighter-rouge">.send()</code> method), the refactoring was easier to manage.</p>

<p>Steps:</p>

<ul>
  <li>Replace Combine subjects with <a href="https://github.com/keeshux/subject-streams"><em>subject streams</em></a></li>
  <li>Return an <code class="language-plaintext highlighter-rouge">AsyncStream</code> from a subject with <code class="language-plaintext highlighter-rouge">.subscribe()</code></li>
  <li>Replace <code class="language-plaintext highlighter-rouge">AnyCancellable</code> with <code class="language-plaintext highlighter-rouge">Task</code> and <code class="language-plaintext highlighter-rouge">for [try] await</code> loops (<code class="language-plaintext highlighter-rouge">weak self</code> here)</li>
</ul>

<p>Before:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">RandomGenerator</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>

    <span class="k">var</span> <span class="nv">publisher</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">generator</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">generator</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="o">.</span><span class="nf">random</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="mi">1</span><span class="o">...</span><span class="mi">1000</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="k">let</span> <span class="nv">prng</span> <span class="o">=</span> <span class="kt">RandomGenerator</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">subscription</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">publisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">value</span> <span class="k">in</span>
    <span class="o">...</span>
<span class="p">}</span>

</code></pre></div></div>

<p>After:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">RandomGenerator</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">PassthroughStream</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">()</span>

    <span class="k">var</span> <span class="nv">publisher</span><span class="p">:</span> <span class="kt">AsyncStream</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">generator</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">generator</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="o">.</span><span class="nf">random</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="mi">1</span><span class="o">...</span><span class="mi">1000</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="k">let</span> <span class="nv">prng</span> <span class="o">=</span> <span class="kt">RandomGenerator</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">subscription</span> <span class="o">=</span> <span class="kt">Task</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="k">in</span>
    <span class="k">for</span> <span class="k">await</span> <span class="n">value</span> <span class="k">in</span> <span class="n">prng</span><span class="o">.</span><span class="n">publisher</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="bottom-line">Bottom line</h2>

<p>Leaving Combine behind is a disruptive step towards both Swift 6 and cross-platform. Personally, I still don’t fully trust the behavior of <code class="language-plaintext highlighter-rouge">AsyncSequence</code>, but what are we left with? Apple is forcing developers towards Concurrency, and soon there will be no choice but to embrace it. And I’m glad, because it’s finally bringing consistency to the language.</p>

<p>We’re close to building the Partout core on both Windows and Linux. In the next article, I will cover some quirks I’m facing with the core libraries.</p>]]></content><author><name>Davide De Rosa</name></author><category term="development" /><category term="swift" /><summary type="html"><![CDATA[The very first goal of porting may sound simple: a successful build. Once you manage to just compile your package, the worst is definitely behind you. Keep in mind that this is not a series about how to port Apple frameworks or SwiftUI to other platforms, it’s about the bare Swift language. I want to show you how Xcode may trick you into thinking that some patterns are a key part of Swift, whereas they should be avoided if you plan to leave the Apple ecosystem at some point. Today, I’ll talk about a kind of infamous framework for Swift developers: Combine. Combine is unofficially obsolete When the compiler suddenly stopped at some occurrence of import Combine, I was beaten. Combine has been a fundamental piece of reactive programming for the last 5+ years, and any recent Swift codebase uses Combine to some extent. The scary question was: to what extent was I using it? Let me digress a moment. There is a big problem with Combine, and it’s not about the developers using it. Apple is well-known for disrupting its own frameworks regardless of any backward-compatibility, and Combine is one of those examples where Apple took a different turn without offering a full replacement. Initially, it seemed that SwiftUI was all about Combine, but the introduction of Concurrency made the poor framework an outcast. Unsurprisingly, ObservableObject and @Published are also unavailable outside Apple Swift, but if you’ve been a diligent programmer, you’ve probably learned that those constructs only make sense with SwiftUI. The fact that Combine has never been integrated into the Swift language, reveals that Concurrency is how Swift (and Apple) wants you to perform asynchronous programming from now on. Does Swift natively offer a substitute for the long list of Combine operators? Hell, no, and that’s why people still use Combine. Back to my question. Luckily, my use of Combine in Partout was quite basic, except for one .combineLatest3() that was worth half the effort. Porting to AsyncSequence If you remember, the purpose of Combine is manipulating a sequence of asynchronous values. Swift offers implementations of AsyncSequence like AsyncStream and AsyncThrowingStream to accomplish the same in a linear fashion, typical of the async/await model. What in Combine was: subscription = somePublisherOfStrings() // AnyPublisher&lt;String, Never&gt; .removeDuplicates() .sink { [weak self] in print("String: \($0)") } becomes this with AsyncStream: subscription = Task { [weak self] in var previous: String? for await string in someStreamOfStrings() { // AsyncStream&lt;String&gt; guard string != previous else { continue } print("String: \($0)") previous = string } } Now, a typical way to spawn Combine publishers is with subjects (PassthroughSubject and CurrentValueSubject), that are multicast emitters of values. Multiple programs can subscribe to a subject, listen to its sequence of values, and manipulate them before delivery with the rich offer of Combine operators. We lack such a counterpart in Swift, so I went to roll out my own. My PassthroughStream and CurrentValueStream implement a simple pub/sub pattern with AsyncStream and strict Swift 6.1 Concurrency. They have become the building blocks of all my asynchronous publishers in cross-platform Swift, and by keeping behavior and naming close to Combine (e.g. the .send() method), the refactoring was easier to manage. Steps: Replace Combine subjects with subject streams Return an AsyncStream from a subject with .subscribe() Replace AnyCancellable with Task and for [try] await loops (weak self here) Before: final class RandomGenerator { private let generator = PassthroughSubject&lt;Int, Never&gt;() var publisher: AnyPublisher&lt;Int, Never&gt; { generator.eraseToAnyPublisher() } func run() { generator.send(.random(in: 1...1000)) } } ... let prng = RandomGenerator() var subscription = prng.publisher.sink { [weak self] value in ... } After: final class RandomGenerator { private let generator = PassthroughStream&lt;Int&gt;() var publisher: AsyncStream&lt;Int&gt; { generator.subscribe() } func run() { generator.send(.random(in: 1...1000)) } } ... let prng = RandomGenerator() var subscription = Task { [weak self] in for await value in prng.publisher { ... } } Bottom line Leaving Combine behind is a disruptive step towards both Swift 6 and cross-platform. Personally, I still don’t fully trust the behavior of AsyncSequence, but what are we left with? Apple is forcing developers towards Concurrency, and soon there will be no choice but to embrace it. And I’m glad, because it’s finally bringing consistency to the language. We’re close to building the Partout core on both Windows and Linux. In the next article, I will cover some quirks I’m facing with the core libraries.]]></summary></entry></feed>